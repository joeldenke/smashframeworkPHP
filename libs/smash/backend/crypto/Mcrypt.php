<?php
/**
 * 
 * Generated by
 * Smash Framework Commentator
 * with PHP Version 5.3.4
 * 
 *  DESCRIPTION
 * Smash Framework is a Open Source PHP web framework to make it easier, efficient and more fun to create web applications.
 * 
 *  LICENSE
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 * 
 * @author      Joel Denke <mail@happyness.se>
 * @category    Smash - Smash Makes A Sweet Harmony
 * @copyright   (C) 2011 Joel Denke
 * @license     http://www.opensource.org/licenses/gpl-3.0.html - GNU General Public License version 3
 * @version     alpha 0.1
 */
	namespace Smash\Backend\Crypto;

	use   	Smash\Core,
		Smash\Library;

	/**
	 * Description goes here ...
	 * 
	 * @namespace    Smash\Backend\Crypto
	 * @uses         Smash\Core,  Smash\Library
	 * @interfaces   Smash\Backend\Crypto\Surface
	 * @package      Mcrypt
	 * @author       Joel Denke <mail@happyness.se>
	 * @license      http://www.opensource.org/licenses/gpl-3.0.html - GNU General Public License version 3
	 */
	class Mcrypt implements Surface
	{
		private $module;
		private $privateKey = null;
		private $options    = array(
			'algorithm'      => 'twofish',
			'method'         => 'twofish',
			'cipher'         => 'twofish',
			'padding'        => false,
			'mode'           => 'cbc',
			'hash'           => 'md5',
			'hashLength'     => 27,
			'salt'           => 'smash.backend.crypto.mcrypt',
			'saltLength'     => 16,
			'keySize'        => 128,
			'modeDir'        => '',
			'algorithmDir'   => ''
		);

		/**
		 * Description goes here ...
		 * 
		 * @access   public
		 * @param    $key (required)
		 * @param    $options (optional)
		 */
		public function __construct($key, $options = null)
		{
			if (!extension_loaded('mcrypt')) {
				throw Core::error('Extension mcrypt is not loaded');
			} else {
				if (is_array($options)) {
					$this->setOptions($options);
				}

				$this->privateKey = $key;
			}
		}

		/**
		 * Description goes here ...
		 * 
		 * @access   public
		 */
		public function __destruct()
		{
			if (is_resource($this->module)) {
				if (get_resource_type($this->module) == 'mcrypt') {
					mcrypt_module_close($this->module);
				}
			}
		}

		/**
		 * Description goes here ...
		 * 
		 * @access   private
		 * @param    $options (Array, required)
		 */
		private function isDirOptionsSet(array $options)
		{
			return (isset($options['algorithmDir']) || isset($options['modeDir']));
		}

		/**
		 * Description goes here ...
		 * 
		 * @access   private
		 */
		private function loadModule()
		{
			$this->module = mcrypt_module_open(
				$this->getOption('algorithm'),
				$this->getOption('algorithmDir'),
				$this->getOption('mode'),
				$this->getOption('modeDir')
			);
			return $this->module;
		}

		/**
		 * Description goes here ...
		 * 
		 * @access   private
		 * @param    $stack (Array, required)
		 */
		private function fixDirStack(array $stack)
		{
			if ($this->isDirOptionsSet($stack)) {
				if (!empty($stack['algorithmDir'])) {
					$algorithmDir = $stack['algorithmDir'];
					unset($stack['algorithmDir']);
					array_unshift($stack, $algorithmDir);
				}
				if (!empty($stack['modeDir'])) {
					$modeDir = $stack['modeDir'];
					unset($stack['modeDir']);
					array_unshift($stack, $modeDir);
				}
			}

			return $stack;
		}

		/**
		 * Description goes here ...
		 * 
		 * @access   public
		 * @param    $options (Array, required)
		 */
		public function setOptions(array $options)
		{
			$options = $this->fixDirStack($options);

			foreach ($options as $option => $value) {
				if ($this->isValidOption($value, $option)) {
					$this->options[$option] = $value;
				}
			}
		}

		/**
		 * Description goes here ...
		 * 
		 * @access   public
		 */
		public function getOptions()
		{
			return $this->options;
		}

		/**
		 * Description goes here ...
		 * 
		 * @access   public
		 * @param    $option (required)
		 */
		public function getOption($option)
		{
			if (array_key_exists($option, $this->options)) {
				return $this->options[$option];
			} else {
				throw Smash::error('Option "'. $option .'" is not available');
			}
		}

		/**
		 * Description goes here ...
		 * 
		 * @access   public
		 * @param    $option (required)
		 * @param    $value (required)
		 */
		public function setOption($option, $value)
		{
			if (array_key_exists($option, $this->options)) {
				$this->options[$option] = $value;
			} else {
				throw Smash::error('Option "'. $option .'" is not available');
			}
		}

		/**
		 * Description goes here ...
		 * 
		 * @access   public
		 * @param    $value (required)
		 * @param    $type (required)
		 */
		public function isValidOption($value, $type)
		{
			switch ($type)
			{
				case 'algorithm' :
				case 'method'    :
				case 'cipher'    :
					$valid = mcrypt_list_algorithms($this->getOption('algorithmDir'));
					break;
				case 'padding' :
					if (!empty($value) || is_bool($value)) {
						return true;
					} else {
						return false;
					}
					break;
				case 'mode'          :
					$valid = mcrypt_list_modes($this->getOption('modeDir'));
					break;
				case 'hash'          :
				case 'salt'          :
					if (is_string($value)) {
						return true;
					} else {
						return false;
					}
					break;
				case 'hashLength'    :
				case 'saltLength'    :
					if (is_int($value) && $value > 0) {
						return true;
					} else {
						return false;
					}
				case 'keySize'       :
					return is_int($value) ? true : false;
					break;
				case 'modeDir'       :
				case 'algorithmDir'  :
					if (is_readable($value) || empty($value)) {
						return true;
					} else {
						return false;
					}
					break;
				default              :
					throw Core::error('You specified an option which not is valid: '. $type);
			}

			return array_key_exists($value, $valid);
		}

		/**
		 * Description goes here ...
		 * 
		 * @access   public
		 * @param    $size (required)
		 */
		public function getValidKeySize($size)
		{
			$supported = mcrypt_enc_get_supported_key_sizes($this->module);

			if (in_array($size, $supported)) {
				return $size;
			} else {
				return mcrypt_enc_get_key_size($this->module);
			}
		}

		/**
		 * Description goes here ...
		 * 
		 * @access   private
		 * @param    $data (required)
		 */
		private function fixPad($data)
		{
			if (is_bool($this->getOption('padding'))) {
				switch ($this->getOption('padding')) {
					case true :
						return $data;
						break;
					case false :
						return rtrim($data);
						break;
				}
			} else {
				$data = rtrim($data);
				return rtrim($data, $this->getOption('padding'));
			}
		}

		/**
		 * Description goes here ...
		 * 
		 * @access   public
		 * @param    $data (required)
		 */
		public function decrypt($data)
		{
			if (empty($data)) {
				return $data;
			}

			$module = $this->loadModule();
			$data       = base64_decode($data);
			$ivSize     = mcrypt_enc_get_iv_size($module);
			$keySize    = $this->getValidKeySize($this->getOption('keySize'));
			$strongKey  = Hash::generate($this->getOption('hash'), $this->privateKey, $this->getOption('salt'), $this->getOption('saltLength'));
			$strongKey  = substr($strongKey, 0, $keySize);
			$iv         = substr($data, 0, $ivSize);
			$data       = substr($data, $ivSize);
			$init       = mcrypt_generic_init($module, $strongKey, $iv);

			if ($init < 0 || $init === false) {
				throw Core::error('Could not initialize mcrypt generic');
			} else {
				$decrypted = mdecrypt_generic($module, $data);
				$decrypted = $this->fixPad($decrypted);

				mcrypt_generic_deinit($module);
				mcrypt_module_close($module);

				return $decrypted;
			}
		}

		/**
		 * Description goes here ...
		 * 
		 * @access   public
		 * @param    $data (required)
		 */
		public function encrypt($data)
		{
			if (empty($data)) {
				return $data;
			}

			$module = $this->loadModule();
			$ivSize     = mcrypt_enc_get_iv_size($module);
			$keySize    = $this->getValidKeySize($this->getOption('keySize'));
			$strongKey  = Hash::generate($this->getOption('hash'), $this->privateKey, $this->getOption('salt'), $this->getOption('saltLength'));
			$strongKey  = substr($strongKey, 0, $keySize);
			$iv         = mcrypt_create_iv($ivSize, MCRYPT_RAND);
			$padding    = !is_bool($this->getOption('padding')) ? $this->getOption('padding') : null;
			$init       = mcrypt_generic_init($module, $strongKey, $iv);

			if ($init < 0 || $init === false) {
				throw Smash::error('Could not initialize mcrypt generic');
			} else {
			    $encrypted = mcrypt_generic($module, $data);
			    mcrypt_generic_deinit($module);

				return base64_encode($iv . $encrypted);
			}
		}
	}
?>