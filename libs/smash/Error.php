<?php
/**
 * 
 * Generated by
 * Smash Framework Commentator
 * with PHP Version 5.3.4
 * 
 *  DESCRIPTION
 * Smash Framework is a Open Source PHP web framework to make it easier, efficient and more fun to create web applications.
 * 
 *  LICENSE
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 * 
 * @author      Joel Denke <mail@happyness.se>
 * @category    Smash - Smash Makes A Sweet Harmony
 * @copyright   (C) 2011 Joel Denke
 * @license     http://www.opensource.org/licenses/gpl-3.0.html - GNU General Public License version 3
 * @version     alpha 0.1
 */
	namespace Smash;

	/**
	 * Description goes here ...
	 * 
	 * @namespace   Smash
	 * @extends     Exception
	 * @package     Error
	 * @author      Joel Denke <mail@happyness.se>
	 * @license     http://www.opensource.org/licenses/gpl-3.0.html - GNU General Public License version 3
	 */
	class Error extends \Exception
	{
		const CODE_MVC  = 1003;
		const CODE_CORE = 1004;
		const CODE_USER = 0;

		private $debug;
		private $context;

		private static $options = array(
			'format'        => 'html',
			'useTrace'      => true,
			'startEntry'    => 0,
			'startLine'     => 1,
			'endLine'       => false,
			'depth'         => 100,
			'highlightSize' => 5,
			'highlight'     => true
		);

		static private $levels     = array(
			self::CODE_MVC      => 'error.mvc',
			self::CODE_CORE     => 'error.core',
			self::CODE_USER     => 'error.user',
			E_ERROR             => 'error.fatal-runtime',
			E_WARNING           => 'error.runtime-warning',
			E_PARSE             => 'error.compile-error',
			E_NOTICE            => 'error.notice',
			E_CORE_ERROR        => 'error.core-error',
			E_CORE_WARNING      => 'error.core-warning',
			E_COMPILE_ERROR     => 'error.compile-error',
			E_COMPILE_WARNING   => 'error.compile-warning',
			E_USER_ERROR        => 'error.user-error',
			E_USER_WARNING      => 'error.user-warning',
			E_USER_NOTICE       => 'error.user-notice',
			E_STRICT            => 'error.strict',
			E_RECOVERABLE_ERROR => 'error.recoverable'
		);

		/**
		 * Description goes here ...
		 * 
		 * @access   public
		 * @param    $error (required)
		 * @param    $data (required)
		 * @param    $code (optional)
		 * @param    $options (optional)
		 */
		public function __construct($error, $data, $code = 0, $options = null)
		{
			if (!is_int($code)) {
				$code = self::CODE_USER;
			}

			$error = Core::locale($error);

			if (is_array($data)) {
				if (Core::isMode('development')) {
					$this->setDebug($data);
				}

				$error = Error::filterMessage($error, $data);
			}

			if (!empty($options)) {
				$this->setOptions($options);
			}

			parent::__construct($error, $code);
		}

		/**
		 * Description goes here ...
		 * 
		 * @access   public, static
		 * @param    $data (required)
		 * @param    $count (optional)
		 */
		static public function filterData($data, $count = 0)
		{
			foreach ($data as $key => $value) {
				$name = is_string($key) && $count > 0 ? var_export($key, true) .' => ' : null;

				switch(gettype($value)) {
					case 'array'    :
						$data[$key] = ($count > 0 ? "\n". str_repeat("\t", $count) . $name : null) ."array(". implode(', ', self::filterData($value, $count+1)) .")";
						break;
					case 'object'   :
						$data[$key] = $name . '[object ' . get_class($value) . ']';
						break;
					case 'resource' :
						$data[$key] = $name . '[resource ' . get_resource_type($value) . ']';
						break;
					case 'string'   :
						$data[$key] = $name .'"'. self::trimFilePath($value) .'"';
						break;
					default :
						$data[$key] = $name . var_export($value, true);
						break;
				}
			}

			return $data;
		}

		/**
		 * Description goes here ...
		 * 
		 * @access   public, static
		 * @param    $message (required)
		 * @param    $data (Array, required)
		 */
		static public function filterMessage($message, array $data)
		{
			if (!empty($data)) {
				$data   = self::filterData($data);
				$values = array();				

				foreach ($data as $key => $value) {
					if (is_int($key)) {
						$values[] = $value;
					} else if (strpos($message, "%$key") !== false) {
						$message = str_replace("%$key", $value, $message);
					}
				}
				
				if (!empty($values)) {
					array_unshift($values, $message);
					$message = call_user_func_array('sprintf', $values);
				}
			}

			return $message;
		}

		/**
		 * Description goes here ...
		 * 
		 * @access   public, static
		 * @param    $file (required)
		 */
		static public function trimFilePath($file)
		{
			if (Core::isModule(Core::$currentModule)) {
				$module  = Core::getModule(Core::$currentModule);
				$base    = Core::$libs;
				$root    = Core::cleanPath(dirname($base));
				$library = Core::cleanPath($base);
				$smash   = Core::cleanPath($base .'smash');
				$app     = $module->getPath();

				if (strpos($file, $app) === 0) {
					return str_replace($app, 'APP', $file);
				} else if (strpos($file, $smash) === 0) {
					return str_replace($smash, 'SMASH'. Core::DS, $file);
				} else if (strpos($file, $library) === 0) {
					return str_replace($library, 'LIBRARY'. Core::DS, $file);
				} else if (strpos($file, $root) === 0) {
					return str_replace($root, 'ROOT'. Core::DS, $file);
				}
			}

			return $file;
		}

		/**
		 * Description goes here ...
		 * 
		 * @access   public, static
		 * @param    $options (Array, required)
		 */
		static public function setOptions(array $options)
		{
			foreach ($options as $key => $value) {
				self::setOption($key, $value);
			}
		}

		/**
		 * Description goes here ...
		 * 
		 * @access   public, static
		 * @param    $option (required)
		 * @param    $value (required)
		 */
		static public function setOption($option, $value)
		{
			if (array_key_exists($option, self::$options)) {
				self::$options[$option] = $value;
			}
		}

		/**
		 * Description goes here ...
		 * 
		 * @access   public, static
		 */
		static public function getOptions()
		{
			return self::$options;
		}

		/**
		 * Description goes here ...
		 * 
		 * @access   public, static
		 * @param    $option (required)
		 */
		static public function getOption($option)
		{
			if (array_key_exists($option, self::$options)) {
				return self::$options[$option];
			}
		}

		/**
		 * Description goes here ...
		 * 
		 * @access   public, static
		 * @param    $var (required)
		 * @param    $label (optional)
		 * @param    $echo (optional)
		 */
		static public function dump($var, $label = null, $echo = false)
		{
			$label = ($label === null) ? '' : rtrim($label) . ' ';

			ob_start();
			var_dump($var);
			$output = ob_get_clean();

			$output = preg_replace("/\]\=\>\n(\s+)/m", "] => ", $output);
			if (PHP_SAPI == 'cli') {
				$output = PHP_EOL . $label
						. PHP_EOL . $output
						. PHP_EOL;
			} else {
				$output = $label
					. PHP_EOL . '<pre>'
					. PHP_EOL . htmlentities($output, ENT_QUOTES, 'UTF-8')
					. '</pre>';
			}

			if ($echo) {
				echo $output;
			} else {
				return $output;
			}
		}

		/**
		 * Description goes here ...
		 * 
		 * @access   public
		 */
		public function __toString()
		{
			try {
				$options  = $this->getOptions();
				$trace    = $this->cleanupTrace($this->getTrace(), $options);
				$string[] = sprintf("<h1>%s</h1> <h2><i>(%s - %d)</i></h2>\n", $this->getMessage(), $this->getLevel($this->getCode()), $this->getCode());
				
				if ($options['useTrace']) {
					$file = $trace[0]['file'];
					$line = $trace[0]['line'];
				} else {
					$file = $this->getFile();
					$line = $this->getLine();
				}

				if (Core::isMode('development')) {
					if ($this->getOption('highlight') && \Smash\Serialize\Highlight::hasHighlighter($file)) {
						$string[] = sprintf("<h2>%s</h2>\n%s\n", Core::locale('error.code-excerpt'). ':', $this->fileExcerpt($file, $line, $options));
					}

					$string[] = sprintf(
						Core::locale('general.file', array('file' => self::trimFilePath($file))).
						"<br />\n". Core::locale('general.line', array($line)). "\n\n%s\n\n",
						"<h2>". Core::locale('error.backtrace'). ":</h2><br />\n<i>" . $this->formatTrace($trace, $options) .'</i>'
					);
					$string[] = sprintf("%s\n\n", $this->dump($this->getDebug(), '<h2>'. Core::locale('error.debug'). ': </h2>'));
				}
			} catch (Error $e) {
				echo $e->getMessage();
				echo $e->getFile();
				echo $e->getLine();
			}

			return implode('', $string);
		}

		/**
		 * Description goes here ...
		 * 
		 * @access   public
		 * @param    $file (required)
		 */
		public function setFile($file)
		{
			$this->file = $file;
		}

		/**
		 * Description goes here ...
		 * 
		 * @access   public
		 * @param    $line (required)
		 */
		public function setLine($line)
		{
			$this->line = $line;
		}

		/**
		 * Description goes here ...
		 * 
		 * @access   public, static
		 * @param    $code (required)
		 */
		static public function getLevel($code)
		{
			if (array_key_exists($code, self::$levels)) {
				return Core::locale(self::$levels[$code]);
			} else {
				return Core::locale('error.unknown');
			}
		}

		/**
		 * Description goes here ...
		 * 
		 * @access   public
		 * @param    $debug (required)
		 */
		public function setDebug($debug)
		{
			$this->debug = $debug;
		}

		/**
		 * Description goes here ...
		 * 
		 * @access   public
		 */
		public function getDebug()
		{
			return $this->debug;
		}

		/**
		 * Description goes here ...
		 * 
		 * @access   public
		 * @param    $context (required)
		 */
		public function setContext($context)
		{
			$this->context = $context;
		}

		/**
		 * Description goes here ...
		 * 
		 * @access   public
		 */
		public function getContext()
		{
			return $this->context;
		}

		/**
		 * Description goes here ...
		 * 
		 * @access   protected
		 * @param    $file (required)
		 * @param    $line (required)
		 * @param    $options (Array)
		 */
		protected function fileExcerpt($file, $line, array $options = array())
		{
			$options = array_merge(
				$options,
				array(
					'highlightLine' => $line,
					'highlightSize' => 5,
					'linebreaks'    => false
				)
			);

			if (is_readable($file)) {
				return Library::factory('serialize.highlight', $file, $options)->toList(true);
			}
		}

		/**
		 * Description goes here ...
		 * 
		 * @access   private
		 * @param    $backtrace (Array, required)
		 * @param    $options (Array, required)
		 * @param    $deep (optional)
		 */
		private function formatTrace(array $backtrace, array $options, $deep = 0)
		{
			$formatted = array();

			foreach (array_reverse($backtrace) as $key => $entry) {
				switch (strtolower($options['format'])) {
					case 'html' :
						$glue             = "<br />". Core::CRLF;
						$formatted[$key]  = "<strong>#{$key}</strong> {$entry['pointer']} - ";
						$formatted[$key] .= " {$entry['callback']}";
						break;
					case 'plain' :
						$glue            = Core::CRLF;
						$formatted[$key] = "{$entry['pointer']}  -  call: {$entry['class']}{$entry['type']}{$entry['function']}({$entry['args']})";
						break;
				}
			}

			return implode($glue, $formatted);
		}

		/**
		 * Description goes here ...
		 * 
		 * @access   private
		 * @param    $backtrace (Array, required)
		 * @param    $options (Array, required)
		 * @param    $deep (optional)
		 */
		private function cleanupTrace(array $backtrace, array $options, $deep = 0)
		{
			foreach ($backtrace as $key => $bt) {
				$trace = array_merge(
					array(
						'file' => '[internal]',
						'line' => '??'
					),
					$backtrace[$key]
				);

				if (isset($backtrace[$key + 1])) {
					$next = array_merge(
						array(
							'line'      => '??',
							'file'      => '[internal]',
							'class'     => null,
							'function'  => '[main]'
						),
						$backtrace[$key + 1]
					);

					$backtrace[$key]['callback'] = $next['function'];

					if (!empty($next['class'])) {
						$backtrace[$key]['callback'] = $next['class'] . $next['type'] . $backtrace[$key]['callback'];
					}

					if (isset($next['args'])) {
						$args = array();

						foreach ($next['args'] as $a) {
							switch (gettype($a)) {
								case 'integer' :
								case 'double'  :
									$args[] = $a;
									break;
								case 'string':
									$a = htmlspecialchars(substr($a, 0, 32)).((strlen($a) > 32) ? '...' : '');
									$args[] = "\"$a\"";
									break;
								case 'array':
									$args[] = 'Array('.count($a).')';
									break;
								case 'object':
									$args[] = 'Object('. get_class($a) .')';
									break;
								case 'resource':
									$args[] = 'Resource('. strstr($a, '#') .')';
									break;
								case 'boolean':
									$args[] = $a ? 'True' : 'False';
									break;
								case 'NULL':
									$args[] = 'Null';
									break;
								default:
									$args[] = 'Unknown';
							}
						}
					}

					$backtrace[$key]['callback'] .= '('. implode(', ', $args) .')';
				} else {
					$backtrace[$key]['callback'] = '[main]';
				}

				if ($trace['file'] == '[internal]') {
					$backtrace[$key]['pointer'] = $trace['file'];
				} else {
					$backtrace[$key]['pointer'] = $this->trimFilePath($trace['file']) ."({$trace['line']})";
				}
			}

			return array_slice($backtrace, $options['startEntry'], $options['depth']);
		}
	}
?>
