<?php
/**
 * 
 * Generated by
 * Smash Framework Commentator
 * with PHP Version 5.3.4
 * 
 *  DESCRIPTION
 * Smash Framework is a Open Source PHP web framework to make it easier, efficient and more fun to create web applications.
 * 
 *  LICENSE
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 * 
 * @author      Joel Denke <mail@happyness.se>
 * @category    Smash - Smash Makes A Sweet Harmony
 * @copyright   (C) 2011 Joel Denke
 * @license     http://www.opensource.org/licenses/gpl-3.0.html - GNU General Public License version 3
 * @version     alpha 0.1
 */
	namespace Smash\Storage;

	use Smash\Core;

	/**
	 * Description goes here ...
	 * 
	 * @namespace   Smash\Storage
	 * @uses        Smash\Core
	 * @package     Filestream
	 * @author      Joel Denke <mail@happyness.se>
	 * @license     http://www.opensource.org/licenses/gpl-3.0.html - GNU General Public License version 3
	 */
	class Filestream
	{
		const DEFAULT_READSIZE  = 1024;
		const MAX_LINE_READSIZE = 40960;
		const LOCKS_BLOCK       = true;

		const MODE_READ         = 'rb';
		const MODE_WRITE        = 'wb';
		const MODE_APPEND       = 'ab';

		private $lockShared     = null;
		private $lockExclusive  = null;

		private $streams        = array();
		private $locks          = array();
		private $stream         = null;
		private $mode           = self::MODE_READ;

		/**
		 * Description goes here ...
		 * 
		 * @access   public
		 * @param    $file (optional)
		 * @param    $mode (optional)
		 * @param    $lock (optional)
		 */
		public function __construct($file = null, $mode = self::MODE_READ, $lock = false)
		{
			$this->lockShared    = LOCK_SH | (self::LOCKS_BLOCK ? 0 : LOCK_NB);
			$this->lockExclusive = LOCK_EX | (self::LOCKS_BLOCK ? 0 : LOCK_NB);

			if (!empty($file)) {
				$this->mode   = $mode;
				$this->stream = $this->getStream($file, $mode, $lock);
			}
		}

		/**
		 * Description goes here ...
		 * 
		 * @access   public
		 */
		public function getFileStream()
		{
			if ($this->isValid($this->stream)) {
				return $this->stream;
			} else {
				throw Core::error('Current stream is not a valid file stream');
			}
		}

		/**
		 * Description goes here ...
		 * 
		 * @access   public
		 */
		public function __destruct()
		{
			$this->closeAll();
		}

		/**
		 * Description goes here ...
		 * 
		 * @access   private
		 * @param    $file (required)
		 */
		private function isValid($file)
		{
			if (is_resource($file)) {
				return (get_resource_type($file) == 'stream');
			} else if (is_file($file)) {
				return true;
			}

			return false;
		}

		/**
		 * Description goes here ...
		 * 
		 * @access   protected
		 * @param    $file (optional)
		 * @param    $mode (optional)
		 * @param    $lock (optional)
		 */
		protected function getStream($file = null, $mode = self::MODE_READ, $lock = false)
		{
			if ($file === null) {
				return $this->getFileStream();
			} else if (!isset($this->streams[$file][$mode]) || !is_resource($this->streams[$file][$mode])) {
				switch ($mode) {
					case self::MODE_READ :
						if (!Core::exists($file)) {
							throw Core::error('File %file does not exist', array('file' => $file));
						} else if (!preg_match('/^.+(?<!file):\/\//i', $file)) {
							throw Core::error('Invalid file name %file', array('file' => $file));
						}
						break;
					case self::MODE_APPEND :
					case self::MODE_WRITE  :
						if (file_exists($file)) {
							if (!is_writable($file)) {
								throw Core::error('File %file is not writable', array('file' => $file));
							}
						} else if (file_exists(dirname($file))) {
							$dir = dirname($file);

							if (!is_writable($dir)) {
								if (!chmod($dir, 0755)) {
									if (!is_writable($dir)) {
										throw Core::error('Directory %dir is not writable', array('dir' => $dir));
									}
								}
							}
						} else {
							throw Core::error('Directory %dir does not exist', array('dir' => dirname($file)));
						}
						
						break;
					default :
						throw Core::error('Invalid mode: %mode', array('mode' => $mode));
				}

				$this->mode                            = $mode;
				$this->streams[$file][$mode] = @fopen($file, $mode);

				if (!is_resource($this->streams[$file][$mode])) {
					throw Core::error('Failed while trying to open a stream for file %file', array('file' => $file));
				}
			}

			if ($lock) {
				$lock = $mode == self::MODE_READ ? self::LOCK_SHARED : self::LOCK_EXCLUSIVE;

				if (@flock($this->streams[$file][$mode], $lock)) {
					$this->locks[] = $this->streams[$file][$mode];
				} elseif (self::LOCKS_BLOCK) {
					throw Core::error('File %file is already locked', array('file' => $file));
				} else {
					throw Core::error('Could not lock file %file', array('file' => $file));
				}
			}

			return $this->streams[$file][$mode];
		}

		/**
		 * Description goes here ...
		 * 
		 * @access   public
		 * @param    $file (required)
		 * @param    $lock (optional)
		 */
		public function readAll($file, $lock = false)
		{
			if (false === $content = @file_get_contents($file)) {
				throw Core::error('Cannot read from file %file', array('file' => $file));
			} else {
				return $content;
			}
		}

		/**
		 * Description goes here ...
		 * 
		 * @access   public
		 * @param    $file (optional)
		 * @param    $size (optional)
		 * @param    $lock (optional)
		 */
		public function read($file = null, $size = self::DEFAULT_READSIZE, $lock = false)
		{
			if ($size == 0) {
				return $this->readAll($file, $lock);
			}

			$fp = $this->getStream($file, self::MODE_READ, $lock);

			if ($this->mode === self::MODE_READ) {
				return !feof($fp) ? fread($fp, $size) : false;
			} else {
				throw Core::error('Invalid read mode %mode', array('mode' => $this->mode));
			}
		}

		/**
		 * Description goes here ...
		 * 
		 * @access   public
		 * @param    $data (required)
		 * @param    $file (optional)
		 * @param    $mode (optional)
		 * @param    $lock (optional)
		 */
		public function write($data, $file = null, $mode = self::MODE_APPEND, $lock = false)
		{
			$fp = $this->getStream($file, $mode, $lock);

			if (-1 === $bytes = @fwrite($fp, $data, strlen($data))) {
				throw Core::error('Cannot write data to file %file', array('file' => $file));
			}

			return $bytes;
		}

		/**
		 * Description goes here ...
		 * 
		 * @access   public
		 * @param    $file (required)
		 * @param    $lock (optional)
		 */
		public function readLine($file, $lock = false)
		{
			$fp = $this->getStream($file, self::MODE_READ, $lock);

			if ($this->mode === self::MODE_READ) {
				if (feof($fp)) {
					return false;
				} else {
					return rtrim(fgets($fp, self::MAX_LINE_READSIZE), "\r\n");
				}
			} else {
				throw Core::error('Invalid read mode %mode', array('mode' => $this->mode));
			}
		}

		/**
		 * Description goes here ...
		 * 
		 * @access   public
		 * @param    $start (optional)
		 * @param    $end (optional)
		 * @param    $file (optional)
		 * @param    $lock (optional)
		 */
		public function readLines($start = 1, $end = 0, $file = null, $lock = false)
		{
			$lines = array();

			while ($line = $this->readLine($file, $lock) !== false) {
				$lines[] = $line;
			}

			if ($end !== 0) {
				return array_slice($lines, $start - 1, $end, true);
			} else {
				return $lines;
			}
		}

		/**
		 * Description goes here ...
		 * 
		 * @access   public
		 * @param    $line (required)
		 * @param    $file (optional)
		 * @param    $mode (optional)
		 * @param    $crlf (optional)
		 * @param    $lock (optional)
		 */
		public function writeLine($line, $file = null, $mode = self::MODE_APPEND, $crlf = Core::CRLF, $lock = false)
		{
			$fp = $this->getStream($file, $mode, $lock);

			if (-1 === $bytes = fwrite($fp, $line . $crlf)) {
				throw Core::error('Cannot write (%line) to file %file', array('line' => $line, 'file' => $file));
			}

			return $bytes;
		}

		/**
		 * Description goes here ...
		 * 
		 * @access   public
		 * @param    $lines (Array, required)
		 * @param    $indentChar (optional)
		 */
		public function writeLines(array $lines, $indentChar = "\t")
		{
			foreach ($lines as $line) {
				if (is_array($line)) {
					$indent = null;
					$lineBreaks = null;
					$data = array_shift($line);

					if (!empty($line)) {
						$level = array_shift($line);
						$indent = is_int($level) ? str_repeat($indentChar, $level) : null;
					}

					if (!empty($line)) {
						$newLines = array_shift($line);
						$lineBreaks = is_int($newLines) ? str_repeat(Core::CRLF, $newLines) : null;
					}

					$this->writeLine($indent . $data . $lineBreaks);
				} else {
					$this->writeLine($data);
				}
			}
		}

		/**
		 * Description goes here ...
		 * 
		 * @access   public
		 * @param    $file (required)
		 * @param    $mode (required)
		 */
		public function rewind($file = null, $mode)
		{
			$fp = $this->getStream($file, $mode);

			if (!@rewind($fp)) {
				throw Core::error('Cannot place the file cursor in the beginning of file %file', array('file' => $file));
			}

			return true;
		}

		/**
		 * Description goes here ...
		 * 
		 * @access   public
		 */
		public function closeAll()
		{
			for ($i = 0, $c = count($this->locks); $i < $c; $i++) {
				is_resource($this->locks[$i]) and @flock($this->locks[$i], LOCK_UN);
			}

			if (!empty($this->streams)) {
				foreach ($this->streams as $file => $modes) {
					if (is_array($modes)) {
						foreach (array_keys($modes) as $mode) {
							$this->close($file, $mode);
						}
					} else {
						unset($this->streams[$file]);
					}
				}
			}
		}

		/**
		 * Description goes here ...
		 * 
		 * @access   public
		 * @param    $file (required)
		 * @param    $mode (required)
		 */
		public function close($file, $mode)
		{
			if (!isset($this->streams[$file][$mode])) {
				return true;
			}

			$fp = $this->streams[$file][$mode];
			unset($this->streams[$file][$mode]);

			if (is_resource($fp)) {
				@flock($fp, LOCK_UN);

				if (!@fclose($fp)) {
					throw Core::error('Cannot close file %file', array('file' => $file));
				}
			}

			return true;
		}

		/**
		 * Description goes here ...
		 * 
		 * @access   public
		 * @param    $file (required)
		 * @param    $mode (required)
		 */
		public function unlock($file, $mode)
		{
			$fp = $this->getStream($file, $mode);

			if (!@flock($fp, LOCK_UN)) {
				throw Core::error('Cannot unlock file %file', array('file' => $file));
			}

			return true;
		}

		/**
		 * Description goes here ...
		 * 
		 * @access   public
		 * @param    $file (required)
		 */
		public function fileInfo($file)
		{
			$info = array(
				'date' => @filemtime($file),
				'name' => @basename($file),
				'size' => @filesize($file),
				'ext'  => $this->extension($file),
				'mime' => $this->mime($file),
				'perm' => @decoct(@fileperms($file) % 01000)
			);

			clearstatcache();

			return $info;
		}

		/**
		 * Description goes here ...
		 * 
		 * @access   public
		 * @param    $file (required)
		 */
		public function download($file)
		{
			if (!file_exists($file)) {
				throw Core::error('File does not exist: %file', array('file' => basename($file)));
			} else {
				if (headers_sent($filename, $line)) {
					throw Core::error('Cannot download file, because headers already sent in %file, on line %line', array('file' => $filename, 'line' => $line));
				}

				$mime = $this->mime($file);

				if (empty($mime)) {
					$mime = 'application/force-download';
				}

				$size = filesize($file);
				$sent = 0;

				$chunksize = (1024 * 50);
				$fp        = $this->getStream($file, self::MODE_READ);
				$obLevel   = ob_get_level();

				try {
					header('Pragma: public');
					header('Expires: 0');
					header('Cache-Control: must-revalidate, post-check=0, pre-check=0');
					header('Content-Type: '. $mime);
					header('Content-Transfer-Encoding: Binary');
					header('Content-length: '. $size);
					header('Content-Disposition: attachment; filename="'. basename($file) .'"');

					@ini_set('zlib.output_compression', 'Off');
					@set_time_limit(0);
					@ignore_user_abort(true);

					ob_start();

					while (!feof($fp) && connection_status() == 0) {
						echo fread($fp, $chunksize);
						ob_flush();
						flush();
						$sent += $chunksize;
					}

					ob_end_flush();
				} catch (Exception $e) {
		            while (ob_get_level() > $obLevel) {
		            	@ob_end_clean();
		            }

		            throw $e;
				}

				$this->close($file, self::MODE_READ);

				if (connection_status() == 0 && !connection_aborted()) {
					// downloads + 1
					return true;
				} else {
					throw Core::error('Download aborted after '. floor($sent * 100 / $size) .'%');
				}

				exit(0);
			}

			return null;
		}

		/**
		 * Description goes here ...
		 * 
		 * @access   public
		 * @param    $file (required)
		 */
		public function extension($file)
		{
			$ext = pathinfo($file, PATHINFO_EXTENSION);
			return empty($ext) ? null : strtolower($ext);
		}

		/**
		 * Description goes here ...
		 * 
		 * @access   public
		 * @param    $file (required)
		 */
		public function hasExtension($file)
		{
			$extension = $this->extension($file);

			if (empty($extension)) {
				return false;
			} else {
				return true;
			}
		}

		/**
		 * Description goes here ...
		 * 
		 * @access   public
		 * @param    $file (required)
		 */
		public function mime($file)
		{
			if (is_dir($file)) {
				$mime = 'directory';
			} else {
				if (function_exists('mime_content_type')) {
					$mime = mime_content_type($file);
				}
			}

			return isset($mime) ? $mime : null;
		}

		/**
		 * Description goes here ...
		 * 
		 * @access   public, static
		 * @param    $bytes (required)
		 * @param    $decimals (optional)
		 */
		static public function niceSize($bytes, $decimals = 2)
		{
			$prefix =  array('', 'k', 'M', 'G', 'T', 'P', 'E', 'Z', 'Y',
						'X','W','V','U','TD','S','R',
						'Q','PP','O','N','MI','L');
			$pos   = 0;

			while ($bytes >= 1024) {
				$bytes /= 1024;
				$pos++;
			}

			return sprintf('%0.'. $decimals .'f %s', $bytes, $prefix[$pos] .'B');
		}

		/**
		 * Description goes here ...
		 * 
		 * @access   public
		 * @param    $file (required)
		 * @param    $suffix (optional)
		 */
		public function icon($file, $suffix = false)
		{
			if (is_dir($file)) {
				$icon = 'dir';
			} else if ($file == 'uplevel') {
				$icon = 'uplevel';
			} else {
				$type = $this->extension($file);

				switch ($type) {
					case 'ai'      : $icon = 'ai'; break;
					case 'asp'     : $icon = 'asp'; break;
					case 'xml'     : $icon = 'xml'; break;
					case 'css'     : $icon = 'css'; break;
					case 'c4d'     : $icon = 'c4d'; break;
					case 'js'      : $icon = 'js'; break;
					case 'pdf'     : $icon = 'pdf'; break;
					case 'xls'     : $icon = 'excel'; break;
					case 'torrent' : $icon = 'torrent'; break;
					case 'fla'     : case 'swf' : $icon = 'flash'; break;
					case 'zip'     : case 'gz' : $icon = 'zip'; break;
					case 'tar'     : case 'rar' : $icon = 'rar'; break;
					case 'psd'     : case 'pxr' : case 'raw' : $icon = 'ps'; break;
					case 'ppt'     : case 'pps' : case 'pot' : case 'ppz' : $icon = 'ppoint'; break;
					case 'emf'     : case 'gif' : $icon = 'gif'; break;
					case 'tif'     : case 'tiff' : $icon = 'tiff'; break;
					case 'bmp'     : case 'dib' : $icon = 'bmp'; break;
					case 'jfif'    : case 'jpe' : case 'jpeg' : case 'jpg' : case 'png' : $icon = 'jpg'; break;
					case 'inc'     : case 'pl' : case 'sql' : case 'text' : case 'tpl' : case 'txt' : $icon = 'txt'; break;
					case 'doc'     : case 'rtf' : case 'dochtml' : case 'dot' : case 'dothtml' : $icon = 'word'; break;
					case 'htm'     : case 'html' : case 'shtml' : $icon = 'html'; break;
					case 'cfc'     : case 'cfm' : case 'cgi' : case 'php' : case 'php3' : case 'php4' : case 'php5' : $icon = 'dw'; break;
					case 'cda'     : case 'm3u' : case 'mp3' : case 'wav' : case 'mid' : case 'midi' : case 'rmi' : case 'au' : case 'snd' : $icon = 'audio'; break;
					case 'asf'     : case 'asx' : case 'au' : case 'avi' : case 'dvr-ms' : case 'mp2' : case 'mp2v' : case 'mpa' : case 'mpe' : case 'mpeg' :
					case 'mpg'     : case 'mpv2' : case 'm1v' : case 'mid' : case 'midi' : case 'rmi' : case 'snd' : case 'wav' : case 'wax' : case 'wm' :
					case 'wma'     : case 'wmd' : case 'wmdb' : case 'wmv' : case 'wmx' : case 'wpl' : case 'wvx' : $icon = 'video'; break;
					default        : $icon = 'unknown';
				}
			}

			if (!$suffix) {
				$extension = null;
			} else {
				$extension = empty($suffix) ? '.ico' : $suffix;
			}

			return $icon . $extension;
		}

		/**
		 * Description goes here ...
		 * 
		 * @access   public
		 * @param    $path (required)
		 * @param    $manager (required)
		 */
		public function urlPath($path, $manager)
		{
			$base = $this->osPath($path);

			if ($_SERVER['HTTP_HOST'] == 'localhost') {
				return 'http://localhost' . $base;
			} else if (preg_match('/^www\./i', $_SERVER['HTTP_HOST'])) {
				$slice = preg_replace('/^www\./i', '', $_SERVER['HTTP_HOST']);
				return 'http://' . $slice . $base;
			} else {
				$slice = explode('.', $_SERVER['HTTP_HOST']);
				return 'http://' . $slice[1] . "." . $slice[2] . $base;
			}
		}

		/**
		 * Description goes here ...
		 * 
		 * @access   public, static
		 * @param    $path (required)
		 */
		static public function exists($path)
		{
			$file = trim($path);

			if (empty($file)) {
				return false;
			} else if ($file[0] == Core::DS || $file[1] == ':') {
				return @file_exists($file);
			} else {
				$paths = explode(PATH_SEPARATOR, ini_get('include_path'));

				foreach ($paths as $path) {
					$check = Core::cleanPath($path) . $file;

					if (file_exists($check)) {
						return true;
					}
				}
			}

			return false;
		}
	}
?>