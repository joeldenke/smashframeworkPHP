<?php
/**
 * 
 * Generated by
 * Smash Framework Commentator
 * with PHP Version 5.3.4
 * 
 *  DESCRIPTION
 * Smash Framework is a Open Source PHP web framework to make it easier, efficient and more fun to create web applications.
 * 
 *  LICENSE
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 * 
 * @author      Joel Denke <mail@happyness.se>
 * @category    Smash - Smash Makes A Sweet Harmony
 * @copyright   (C) 2011 Joel Denke
 * @license     http://www.opensource.org/licenses/gpl-3.0.html - GNU General Public License version 3
 * @version     alpha 0.1
 */
	namespace Smash\Storage;

	use Smash\Core;

	/**
	 * Description goes here ...
	 * 
	 * @namespace   Smash\Storage
	 * @uses        Smash\Core
	 * @package     Directory
	 * @author      Joel Denke <mail@happyness.se>
	 * @license     http://www.opensource.org/licenses/gpl-3.0.html - GNU General Public License version 3
	 */
	class Directory
	{
		const SORT_NONE   = 1;
		const SORT_NAME   = 2;
		const SORT_SIZE   = 4;
		const SORT_DATE   = 8;
		const SORT_TYPE   = 16;

		const LIST_ALL    = 3;
		const LIST_NORMAL = 6;

		private $skipEntries = array(
			'_vti_bin',
			'_vti_cnf',
			'_vti_log',
			'_vti_pvt',
			'_vti_txt',
			'_vti_inf.html',
			'thumbs.db'
		);
		private $cd          = 'root';
		private $cwd         = null;
		private $root        = null;

		private $sort        = null;
		public  $sortby      = null;
		private $pathModel   = ':root:dir'; // localhost/:root/images/gdmkmkld

		/**
		 * Description goes here ...
		 * 
		 * @access   public
		 * @param    $dir (required)
		 */
		public function __construct($dir)
		{
			if ($this->available($dir)) {
				$this->cwd = $dir;
			}
		}

		/**
		 * Description goes here ...
		 * 
		 * @access   public, static
		 */
		static public function isWindows()
		{
			return defined('OS_WINDOWS') ? OS_WINDOWS : !strncasecmp(PHP_OS, 'win', 3);
		}

		/*----------------------------------------------------------------------
		* Get path relative to another path
		*
		* @access  public
		* @param   string   $path      - Given path
		* @param   string   $root      - Given root
		* @param   string   $separator - Directory separator
		* @return  string              - The relative path
		* ------------------------------------------------------------------------------------------------------------- */
		/**
		 * Description goes here ...
		 * 
		 * @access   public, static
		 * @param    $path (required)
		 * @param    $root (required)
		 * @param    $separator (optional)
		 */
		static public function relativePath($path, $root, $separator = DIRECTORY_SEPARATOR)
		{
			$path = self::transPath($path, $separator);
			$root = self::transPath($root, $separator);
			$dirs = explode($separator, $path);
			$comp = explode($separator, $root);

			if (self::isWindows()) {
				if (strcasecmp($dirs[0], $comp[0])) {
					return $path;
				}
				unset($dirs[0], $comp[0]);
			}

			foreach ($comp as $i => $part) {
				if (isset($dirs[$i]) && $part == $dirs[$i]) {
					unset($dirs[$i], $comp[$i]);
				} else {
					break;
				}
			}

			return str_repeat('..' . $separator, count($comp)) . implode($separator, $dirs);
		}

		/*----------------------------------------------------------------------
		* Get real path (works with non-existant paths)
		*
		* @access  public
		* @param   string   $path      - Given path
		* @param   string   $separator - Directory separator
		* @return  string              - The real path, e.g. C:\ for WIN and / for UNIX
		* ------------------------------------------------------------------------------------------------------------- */
		/**
		 * Description goes here ...
		 * 
		 * @access   public, static
		 * @param    $path (required)
		 * @param    $separator (optional)
		 */
		static public function transPath($path, $separator = DIRECTORY_SEPARATOR)
		{
			if (!strlen($path)) {
				return $separator;
			}

			$drive = '';

			if (self::isWindows()) {
				$path = preg_replace('/[\\\\\/]/', $separator, $path);

				if (preg_match('/([a-zA-Z]\:)(.*)/', $path, $matches)) {
					$drive = $matches[1];
					$path  = $matches[2];
				} else {
					$cwd   = getcwd();
					$drive = substr($cwd, 0, 2);
					if ($path{0} !== $separator{0}) {
						$path  = substr($cwd, 3) . $separator . $path;
					}
				}
			} elseif ($path{0} !== $separator) {
				$path = getcwd() . $separator . $path;
			}

			$dirStack = array();

			foreach (explode($separator, $path) as $dir) {
				if (strlen($dir) && $dir !== '.') {
					if ($dir == '..') {
						array_pop($dirStack);
					} else {
						$dirStack[] = $dir;
					}
				}
			}

			return $drive . $separator . implode($separator, $dirStack);
		}

		/**
		 * Description goes here ...
		 * 
		 * @access   public
		 * @param    $dir (required)
		 */
		public function available($dir)
		{
			return is_readable($dir);
		}

		/**
		 * Description goes here ...
		 * 
		 * @access   public
		 * @param    $root (required)
		 */
		public function setRoot($root)
		{
			$this->root = rtrim(Directory::transPath($root), '\\/');
			return $this;
		}

		/**
		 * Description goes here ...
		 * 
		 * @access   public
		 * @param    $model (required)
		 */
		public function setPathModel($model)
		{
			$this->pathModel = $model;
			return $this;
		}

		/**
		 * Description goes here ...
		 * 
		 * @access   public
		 * @param    $path (required)
		 */
		public function toModelPath($path)
		{
			return str_replace(array($this->root, Core::DS), array('root', ':'), $path);
		}

		/**
		 * Description goes here ...
		 * 
		 * @access   public
		 * @param    $path (required)
		 * @param    $delim (optional)
		 */
		public function clean($path, $delim = DIRECTORY_SEPARATOR)
		{
			return preg_replace('/[\\\\\/]/', $delim, $path);
		}

		/**
		 * Description goes here ...
		 * 
		 * @access   protected
		 * @param    $dir (required)
		 */
		protected function convertToPath($dir)
		{
			$path    = $this->clean($dir);
			$pieces  = explode(':', $path);
			$root    = array_shift($pieces);
			$dirPath = Core::DS . ltrim(implode(Core::DS, $pieces), '\\/');

			$model   = $this->pathModel;
			$search  = array(':root', ':dir');
			$replace = array($this->root, $dirPath);

			return str_replace($search, $replace, $model);
		}

		/**
		 * Description goes here ...
		 * 
		 * @access   public
		 * @param    $path (optional)
		 */
		public function cwd($path = null)
		{
			if (isset($path)) {
				$this->cd = $path;

				if (preg_match('/^root/', $path)) {
					$dirPath   = $this->convertToPath($path);
					$this->cwd = Directory::transPath($dirPath);

					return $this->cwd;
				} else {
					throw Core::error('Possible hacking attack');
				}
			} else if (empty($this->cwd)) {
				$this->cwd = $this->root;

				return $this->cwd;
			} else {
				if ($this->available($this->cwd)) {
					return $this->cwd;
				} else {
					throw Core::error('Not a directory, please check directory path');
				}
			}
		}

		/**
		 * Description goes here ...
		 * 
		 * @access   public
		 */
		public function getCD()
		{
			return $this->cd;
		}

		/**
		 * Description goes here ...
		 * 
		 * @access   public
		 */
		public function cdup()
		{
			$this->cwd = dirname($this->cwd());
			return $this->cwd();
		}

		/**
		 * Description goes here ...
		 * 
		 * @access   public
		 * @param    $path (required)
		 * @param    $delim (optional)
		 */
		public function breadcrumbs($path, $delim = Core::DS)
		{
			if (!$this->available($path)) {
				throw Core::error('Directory not available, please check rights (CHMOD) and directory path: %path', array('path' => $path));
			}

			$path = $this->replaceBase($path);

			$dirs  = explode($delim, $path);
			$var   = '';
			$xhtml = '';

			foreach ($dirs as $dir) {
				if (!empty($dir)) {
					if ($dir == 'root') {
						$var .=  ltrim($delim . $dir, $delim);
						$entries[$dir] = $var;
					} else {
						$var .=  $delim . $dir;
						$entries[$dir] = $var;
					}
				}
			}

			return $entries;
		}

		/**
		 * Description goes here ...
		 * 
		 * @access   public
		 * @param    $dir (required)
		 * @param    $filter (optional)
		 */
		public function getList($dir, $filter = self::LIST_NORMAL)
		{
			if (!$this->available($dir)) {
				throw Core::error('Directory not available, please check rights (CHMOD) and directory path: %path', array('path' => $dir));
			}

			$entries = array();

			foreach (new \DirectoryIterator($dir) as $entry) {
				if ($filter == self::LIST_NORMAL && $entry->isDot()) {
					continue;
				}

				$path = self::transPath($entry->getPathname());

				if ($filter === self::LIST_ALL || $filter === self::LIST_NORMAL) {
					if (in_array(strtolower($entry->getFilename()), $this->skipEntries)) {
						continue;
					} else {
						$entries[] = array(
							'name' => $entry->getFilename(),
							'size' => $entry->isDir() ? $this->dirSize($path) : $entry->getSize(),
							'date' => $entry->getMTime(),
							'type' => $this->mime($path),
							'path' => $path,
							'info' => Smash\Library::factory('SplFileInfo', $path)
						);
					}
				}
			}

			if (!empty($this->sort)) {
				$entries = $this->sort($entries, $this->sort);
			}

			return $entries;
		}

		/**
		 * Description goes here ...
		 * 
		 * @access   private
		 * @param    $files (required)
		 * @param    $sort (required)
		 * @param    $order (optional)
		 */
		private function sort($files, $sort, $order = SORT_DESC)
		{
			if (!$files || !is_array($files)) {
				return array();
			} else if ($sort & self::SORT_NONE) {
				return $files;
			}

			$names = array();
			$sizes = array();
			$dates = array();
			$types = array();

			switch ($sort) {
				case self::SORT_NAME : $r = &$names; break;
				case self::SORT_DATE : $r = &$dates; break;
				case self::SORT_SIZE : $r = &$sizes; break;
				case self::SORT_TYPE : $r = &$types; break;
				default :
					asort($files, SORT_REGULAR);
					return $files;
			}

			$flags = array(
				self::SORT_NAME => SORT_STRING,
				self::SORT_DATE => SORT_NUMERIC,
				self::SORT_SIZE => SORT_NUMERIC,
				self::SORT_TYPE => SORT_STRING,
			);

			foreach ($files as $file) {
				$names[] = $file['name'];
				$sizes[] = $file['size'];
				$dates[] = $file['date'];
				$types[] = $file['type'];
			}

			if ($order === SORT_ASC) {
				arsort($r, $flags[$sort & ~1]);
			} else {
				asort($r, $flags[$sort]);
			}

			$result = array();

			foreach ($r as $i => $f) {
				$result[] = $files[$i];
			}

			return $result;
		}

		/**
		 * Description goes here ...
		 * 
		 * @access   public
		 * @param    $sort (required)
		 */
		public function setSortby($sort)
		{
			$this->sortby = $sort;

			switch($sort) {
				case 'name' :
					$this->sort = self::SORT_NAME;
					break;
				case 'type' :
					$this->sort = self::SORT_TYPE;
					break;
				case 'size' :
					$this->sort = self::SORT_SIZE;
					break;
				case 'date' :
					$this->sort = self::SORT_DATE;
					break;
				default :
					$this->sort = self::SORT_NONE;
			}

			return $this;
		}

		/**
		 * Description goes here ...
		 * 
		 * @access   public
		 * @param    $type (optional)
		 */
		public function stats($type = null)
		{
			$stats = array(
				'freespace'  => @disk_free_space($this->cwd()),
				'totalspace' => @disk_total_space($this->cwd()),
				'size'  => $this->countData($this->cwd(), 'size'),
				'files' => $this->countData($this->cwd(), 'files'),
				'dirs'  => $this->countData($this->cwd(), 'dirs'),
				'lines' => $this->countData($this->cwd(), 'lines')
			);

			clearstatcache();

			return (array_key_exists($type, $stats)
				? $stats[$type]
				: $stats
			);
		}

		/**
		 * Description goes here ...
		 * 
		 * @access   private
		 * @param    $path (required)
		 * @param    $type (optional)
		 * @param    $recursive (optional)
		 */
		private function countData($path, $type = null, $recursive = true)
		{
			if (!$this->available($path)) {
				throw Core::error('Directory not available, please check rights (CHMOD) and directory path: %path', array('path' => $path));
			}

			$count = 0;
			$it       = $recursive
				  ? new \RecursiveIteratorIterator(new \RecursiveDirectoryIterator($path), \RecursiveIteratorIterator::SELF_FIRST)
				  : new \DirectoryIterator($path);

			foreach ($it as $entry) {
				switch ($type) {
					case 'dir' :
					case 'dirs' :
					case 'directories' :
						if (!$entry->isFile()) {
							$count++;
						}
						break;
					case 'files' :
						if ($entry->isFile()) {
							$count++;
						}
						break;
					case 'lines' :
						if ($entry->isFile()) {
							$source = file($entry->getPathname());
							$count += count($source);
						}
						break;
					case 'size' :
						$count += $entry->getSize();
						break;
					default :
						$count++;
						break;
				}
			}

			return $count;
		}

		/**
		 * Description goes here ...
		 * 
		 * @access   public
		 * @param    $dir (required)
		 * @param    $mode (optional)
		 * @param    $overwrite (optional)
		 */
		public function createDir($dir, $mode = 0755, $overwrite = false)
		{
			if (!$overwrite) {
				if ($this->available($dir)) {
					throw Core::error('Directory %directory already exist', array('directory' => $dir));
				}
			}

			if (!@mkdir($dir, $mode, true)) {
				throw Core::error('Rights is missing to create directories');
			} else {
				return true;
			}
		}

		/**
		 * Description goes here ...
		 * 
		 * @access   public
		 * @param    $dir (required)
		 */
		public function deleteDir($dir)
		{
			if (!$this->isAvailable($dir)) {
				throw Core::error('Directory not available, please check rights (CHMOD) and directory path: %path', array('path' => $dir));
			}

			$iterator = new \DirectoryIterator($dir);

			foreach ($iterator as $entry) {
				if ($entry->isDot()) {
					continue;
				}
				if ($entry->isDir()) {
					$this->deleteDir($entry->getPathname());
				} else {
					if (unlink($entry->getPathname())) {
						continue;
					}
				}
			}
			if (!@rmdir($dir)) {
				throw Core::error('Directory %directory could not be deleted properly: $dir', array('directory' => $dir));
			} else {
				return true;
			}
		}
	}
?>