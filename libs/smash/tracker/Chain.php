<?php
/**
 * 
 * Generated by
 * Smash Framework Commentator
 * with PHP Version 5.3.4
 * 
 *  DESCRIPTION
 * Smash Framework is a Open Source PHP web framework to make it easier, efficient and more fun to create web applications.
 * 
 *  LICENSE
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 * 
 * @author      Joel Denke <mail@happyness.se>
 * @category    Smash - Smash Makes A Sweet Harmony
 * @copyright   (C) 2011 Joel Denke
 * @license     http://www.opensource.org/licenses/gpl-3.0.html - GNU General Public License version 3
 * @version     alpha 0.1
 */
	namespace Smash\Tracker;
	
	use	Smash\Core;

	/**
	 * Description goes here ...
	 * 
	 * @namespace    Smash\Tracker
	 * @uses         Smash\Core
	 * @interfaces   Smash\Tracker\Surface
	 * @package      Chain
	 * @author       Joel Denke <mail@happyness.se>
	 * @license      http://www.opensource.org/licenses/gpl-3.0.html - GNU General Public License version 3
	 */
	class Chain implements Surface
	{
		private $status     = false;
		private $unloaded   = array();
		private $components = array();

		/**
		 * Description goes here ...
		 * 
		 * @access   public
		 */
		public function __construct()
		{}

		/**
		 * Description goes here ...
		 * 
		 * @access   public
		 * @param    $path (required)
		 */
		public function getTree($path)
		{
			$dir  = new \DirectoryIterator($path);
			$tree = array();
			$dirs = array();

			foreach ($dir as $entry) {
				$element = $entry->getFilename();

				if ($entry->isDir()) {
					if (!$entry->isDot()) {
						$dirs[$element] = $entry->getPathname();
					}
				} else if ($entry->isFile()) {
					if (preg_match('/\.php$/i', $element)) {
						$tree[str_replace('.php', '', $element)] = str_replace($this->getBase(), '', $entry->getPathname());
					}
				}
			}

			if (!empty($dirs)) {
				foreach ($dirs as $key => $item) {
					$tree[$key] = $this->getTree($item);
				}
			}

			return $tree;
		}

		/**
		 * Description goes here ...
		 * 
		 * @access   public
		 * @param    $chain (Array, required)
		 */
		public function trackChain(array $chain)
		{
			$chain      = array_map('strtolower', $chain);
			$tree       = $this->getTree($this->getBase());
			$components = array();

			foreach ($tree as $key => $element) {
				if (is_string($key)) {
					if (in_array($key, $chain)) {
						$components[$key] = $element;
					} else if (in_array($key, array_map('ucfirst', $chain))) {
						$components[$key] = $element;
					}
				}
			}

			$this->loadChain($components);
		}

		/**
		 * Description goes here ...
		 * 
		 * @access   public
		 * @param    $chain (Array, required)
		 */
		public function loadChain(array $chain)
		{
			// If any value on same key already exists it will not be overwritten ;)
			// After that, the merged chains will be sorted by keys, recursiverly.
			$this->components = $this->sortRecursive($this->mergeRecursive($chain, $this->components));
			$this->initChain();

			return $this;
		}

		/**
		 * Description goes here ...
		 * 
		 * @access   private
		 * @param    $chain (Array, required)
		 */
		private function includeClassChain(array $chain)
		{
			foreach ($chain as $key => $element) {
				if (is_array($element)) {
					$this->includeClassChain($element);
				} else {
					$file  = $this->getFilePath($element);
					$class = $this->elementToClass($element);

					if (!$this->isDefined($class)) {
						$this->includeFile($file);
					}
				}
			}
		}

		/**
		 * Description goes here ...
		 * 
		 * @access   private
		 */
		private function initChain()
		{
			$this->status = true;
			$this->setAutoload(array($this, 'autoload'));
			$this->includeClassChain($this->components);
			$this->setAutoload(array($this, 'autoload'), false);
		}

		/**
		 * Description goes here ...
		 * 
		 * @access   public
		 */
		public function isChainLoaded()
		{
			return $this->status;
		}

		/**
		 * Description goes here ...
		 * 
		 * @access   public
		 * @param    $module (required)
		 */
		public function isModule($module)
		{
			// Case insensitive is the best for nice class names like Smash_MVC!
			return array_key_exists(strtolower($module), $this->components);
		}

		/**
		 * Description goes here ...
		 * 
		 * @access   public
		 * @param    $component (required)
		 */
		public function isComponent($component)
		{
			// Göra en sofistikerad sökmodul
			return in_array(strtolower($component), $this->components);
		}

		/**
		 * Description goes here ...
		 * 
		 * @access   public
		 * @param    $class (optional)
		 */
		public function getClassFile($class = null)
		{
			if ($this->isComponent($class)) {
				return $this->components[strtolower($class)];
			} else {
				return $this->components;
			}
		}

		/**
		 * Description goes here ...
		 * 
		 * @access   public
		 */
		public function getUnloaded()
		{
			return $this->unloaded;
		}

		/**
		 * Description goes here ...
		 * 
		 * @access   public
		 * @param    $class (required)
		 */
		public function track($class)
		{
			Core::includeFile(Core::classToFile($class));

			if (!$this->isDefined($class, false)) {
				array_push($this->unloaded, $class);
				$this->status = false;
				return false;
			}
		}

		/**
		 * Description goes here ...
		 * 
		 * @access   protected
		 * @param    $component (required)
		 * @param    $type (required)
		 */
		protected function getPart($component, $type)
		{
			switch ($type) {
				case 'file' :
					$part = self::getBase() . implode(Core::DS, $component) .'.php';
					break;
				case 'class' :
					$name      = ucfirst(self::getNamespace());
					$component = array_map('ucfirst', $component);
					$part      = $name . implode('_', $component);
					break;
				default :
					throw Core::error('Component type %type does not exist', array('type' => $type));
					break;
			}

			return $part;
		}

		/**
		 * Description goes here ...
		 * 
		 * @access   public
		 * @param    $class (required)
		 */
		public function findClasses($class)
		{
			$parts             = explode('_', $class);
			$parts             = array_map('strtolower', $parts);
			$count             = count($parts);
			$parts[$count - 1] = ucfirst($parts[$count - 1]);
			$matches           = $this->searchRecursive($parts, $this->components);

			if (!$matches) {
				return false;
			} else {
				$classes = array();

				foreach ($matches as $key => $match) {
					$classes[$key] = $this->elementToClass(implode(Core::DS, $match));
				}

				return $classes;
			}
		}

		/**
		 * Description goes here ...
		 * 
		 * @access   public
		 * @param    $array1 (Array, required)
		 * @param    $array2 (Array, required)
		 */
		public function mergeRecursive(array $array1, array $array2)
		{
			$arrays  = func_get_args();
			$remains = $arrays;
			$result  = array();

			foreach($arrays as $array) {
				array_shift($remains);

				if (is_array($array)) {
					foreach ($array as $key => $value) {
						if (is_array($value)) {
							$args = array();

							foreach($remains as $remain) {
								if (array_key_exists($key, $remain)) {
									array_push($args, $remain[$key]);
								}
							}

							if (count($args) > 2) {
								$result[$key] = call_user_func_array(array($this, __FUNCTION__), $args);
							} else {
								foreach($value as $vkey => $vval) {
									$result[$key][$vkey] = $vval;
								}
							}
						} else {
							if (!in_array($value, $result, true)) {
								$result[$key] = $value;
							}
						}
					}
				}
			}

			return $result;
		}

		/**
		 * Description goes here ...
		 * 
		 * @access   public
		 * @param    $unsorted (Array, required)
		 */
		public function sortRecursive(array $unsorted)
		{
			$array = $unsorted;
			array_multisort(array_keys($array), SORT_ASC, SORT_STRING, $array);

			foreach ($array as $key => $value) {
				if (is_array($value)) {
					$array[$key] = $this->sortRecursive($value);
				} else {
					$array[$key] = $value;
				}
			}

			return $array;
		}

		/**
		 * Description goes here ...
		 * 
		 * @access   private
		 * @param    $needle (required)
		 * @param    $haystack (Array, required)
		 * @param    $limit (optional)
		 * @param    $path (optional)
		 */
		private function searchRecursiveSimple($needle, array $haystack, $limit = 0, $path = null)
		{
			if (!isset($path['level'])) {
				$path['level'] = 0;
			}
			if (!isset($path['work'])) {
				$path['work'] = array();
			}

			$count = 0;

			while (!is_null($key = key($haystack))) {
				$value = current($haystack);

				if ($count > 0 && $count === $limit) {
					return $path;
				} else if ($path['next'] === $key) {
					$path['work'][$path['level']] = $key;
					$path['found'][]              = $path['work'];
					$count++;
				} elseif (is_array($value)) {
					$path['work'][$path['level']] = $key;
					$path['level']               += 1;
					$path                         = $this->searchRecursiveSimple($needle, $value, $limit, $path);
					$count                       += count($path['found']);
				}

				next($haystack);
			}

			array_splice($path['work'], $path['level']);
			$path['level'] -= 1;

			return $path;
		}

		/**
		 * Description goes here ...
		 * 
		 * @access   private
		 * @param    $segments (required)
		 * @param    $haystack (Array, required)
		 * @param    $limit (optional)
		 * @param    $path (optional)
		 */
		private function searchRecursiveArray($segments, array $haystack, $limit = 0, $path = null)
		{
			if (!is_array($segments)) {
				$segments = array($segments);
			}
			if (!isset($path['segments'])) {
				$path['segments'] = $segments;
			}
			if (!isset($path['level'])) {
				$path['level'] = 0;
			}
			if (!isset($path['work'])) {
				$path['work'] = array();
			}
			if (!isset($path['next'])) {
				$path['next'] = array_shift($path['segments']);
			}

			$count = 0;

			reset($haystack);

			while (!is_null($key = key($haystack))) {
				$value = current($haystack);

				if ($count > 0 && $count === $limit) {
					return $path;
				} elseif (is_array($value)) {
					if ($path['next'] === $key) {
						if (count($path['segments']) > 0) {
							$path['prev'] = $path['next'];
							$path['next'] = array_shift($path['segments']);
						}
					}

					$path['work'][$path['level']] = $key;
					$path['level']               += 1;
					$path                         = $this->searchRecursiveArray($segments, $value, $limit, $path);
					$count                       += count($path['found']);
				} else if ($path['next'] === $key) {
					if (isset($path['prev'])) {
						if ($path['work'][$path['level'] - 1] !== $path['prev']) {
							next($haystack);
						} else {
							$path['work'][$path['level']] = $key;
							$path['found'][]              = $path['work'];
							$path['segments']             = $segments;
							$path['next']                 = array_shift($path['segments']);
							unset($path['prev']);
							$count++;
						}
					} else {
						// Match single element too ... the other one before only take care of multiple segments
						$path['work'][$path['level']] = $key;
						$path['found'][]              = $path['work'];
						$path['segments']             = $segments;
						$path['next']                 = array_shift($path['segments']);
						unset($path['prev']);
						$count++;
					}
				}

				next($haystack);
			}

			array_splice($path['work'], $path['level']);
			$path['level'] -= 1;

			return $path;
		}

		/**
		 * Description goes here ...
		 * 
		 * @access   public
		 * @param    $needle (required)
		 * @param    $haystack (Array, required)
		 * @param    $limit (optional)
		 */
		public function searchRecursive($needle, array $haystack, $limit = 0)
		{
			$result = $this->searchRecursiveArray($needle, $haystack, $limit);

			if (array_key_exists('found', $result)) {
				return $result['found'];
			} else {
				return false;
			}
		}
	}
?>