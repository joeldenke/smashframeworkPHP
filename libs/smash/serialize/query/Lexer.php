<?php
/**
 * 
 * Generated by
 * Smash Framework Commentator
 * with PHP Version 5.3.4
 * 
 *  DESCRIPTION
 * Smash Framework is a Open Source PHP web framework to make it easier, efficient and more fun to create web applications.
 * 
 *  LICENSE
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 * 
 * @author      Joel Denke <mail@happyness.se>
 * @category    Smash - Smash Makes A Sweet Harmony
 * @copyright   (C) 2011 Joel Denke
 * @license     http://www.opensource.org/licenses/gpl-3.0.html - GNU General Public License version 3
 * @version     alpha 0.1
 */
	namespace Smash\Serialize\Query;

	use	Smash\Serialize\Lexer as MainLexer,
		Smash\Core;

	/**
	 * Description goes here ...
	 * 
	 * @namespace    Smash\Serialize\Query
	 * @uses         Smash\Serialize\Lexer as MainLexer,  Smash\Core
	 * @extends      Smash\Serialize\Lexer
	 * @interfaces   Iterator, Traversable, ArrayAccess, SeekableIterator, Serializable, Countable
	 * @package      Lexer
	 * @author       Joel Denke <mail@happyness.se>
	 * @license      http://www.opensource.org/licenses/gpl-3.0.html - GNU General Public License version 3
	 */
	class Lexer extends MainLexer
	{
		const T_UNKNOWN             = 10;
		const T_IDENTIFIER          = 20;
		const T_INTEGER             = 30;
		const T_STRING              = 40;
		const T_INPUT_PARAMETER     = 50;
		const T_FLOAT               = 60;

		const T_ALL                 = 1001;
		const T_AND                 = 1002;
		const T_ANY                 = 1003;
		const T_AS                  = 1004;
		const T_ASC                 = 1005;
		const T_AVG                 = 1006;
		const T_BETWEEN             = 1007;
		const T_BOTH                = 1008;
		const T_BY                  = 1009;
		const T_COUNT               = 1010;
		const T_CREATE              = 1011;
		const T_DELETE              = 1012;
		const T_DESC                = 1013;
		const T_DISTINCT            = 1014;
		const T_DOT                 = 1015;
		const T_EMPTY               = 1016;
		const T_ESCAPE              = 1017;
		const T_EXISTS              = 1018;
		const T_FALSE               = 1019;
		const T_FROM                = 1020;
		const T_GROUP               = 1021;
		const T_HAVING              = 1022;
		const T_IN                  = 1023;
		const T_INDEX               = 1024;
		const T_INNER               = 1025;
		const T_INSERT              = 1026;
		const T_IS                  = 1027;
		const T_JOIN                = 1028;
		const T_LIKE                = 1029;
		const T_LIMIT               = 1030;
		const T_MAX                 = 1031;
		const T_MEMBER              = 1032;
		const T_MIN                 = 1033;
		const T_MOD                 = 1034;
		const T_NOT                 = 1035;
		const T_NULL                = 1036;
		const T_OF                  = 1037;
		const T_OFFSET              = 1038;
		const T_OR                  = 1039;
		const T_ORDER               = 1040;
		const T_OUTER               = 1041;
		const T_SELECT              = 1042;
		const T_SET                 = 1043;
		const T_SIZE                = 1044;
		const T_SOME                = 1045;
		const T_SUM                 = 1046;
		const T_TRAILING            = 1047;
		const T_TRUE                = 1048;
		const T_UPDATE              = 1049;
		const T_WHERE               = 1050;
		const T_WITH                = 1051;
		const T_PARTIAL             = 1052;
		const T_DATA                = 1053;
		const T_OPERATOR            = 1054;
		const T_TABLE               = 1055;
		const T_FUNCTION            = 1056;
		const T_DATABASE            = 1057;
		const T_PROCEDURE           = 1058;
		const T_TRIGGER             = 1059;
		const T_VIEW                = 1060;
		const T_IF                  = 1061;
		const T_COMMA         		= 1062;
		const T_INTO                = 1063;

		private $operators = array('=', '<>', '<', '<=', '>', '>=', 'like', 'clike', 'slike', 'not', 'is', 'in', 'between');

		/**
		 * Description goes here ...
		 * 
		 * @access   public
		 * @param    $token (required)
		 */
		public function parseToken($token)
		{
			$element = new \StdClass();
			$code    = self::T_UNKNOWN;

			if (strlen($token) < 1) {
				$element->data = $token;
				$element->type = $code;
			} else {
				if ($token[0] === '(' || $token[0] === '{') {
					$code = self::T_DATA;
				} else if (is_scalar($token) && is_numeric($token)) {
					$code = (strpos($token, '.') !== false || stripos($token, 'e') !== false) ? self::T_FLOAT : self::T_INTEGER;
				} else if ($token[0] === "'") {
					$token = str_replace("''", "'", substr($token, 1, strlen($token) - 2));
					$code  = self::T_STRING;
				} else if (ctype_alpha($token[0]) || $token[0] === '_' || $token[0] === "\140") {
					$code = $this->getConstant($token);
				} else if ($token[0] === '?' || $token[0] === ':') {
					$code = self::T_INPUT_PARAMETER;
				} else {
					if (in_array($token, $this->operators)) {
						$code = self::T_OPERATOR;
					}
				}
				
				$element->data = $token;
				$element->type = $code;
			}

			return $element;
		}

		/**
		 * Description goes here ...
		 * 
		 * @access   public
		 * @param    $data (required)
		 */
		public function loopOpenString($data)
		{
			switch ($data[0]) {
				case "'"     :
				case '"'     :
				case "\140"  :
					$char = $data[0];

					if (substr_count($data, $char) % 2) {
						throw Core::error('Invalid syntax');
					}
					break;
				default      :
					throw Core::error('Not in substring offset');
					break;
			}

			$offset = 0;
			$open   = 1;

			/*
			while ($open >= 1) {
				$value = $data[$offset];
						$offset++;

				if ($open % 2) {
				}
			}*/
		}

		/**
		 * Description goes here ...
		 * 
		 * @access   public
		 * @param    $data (required)
		 */
		public function loopToClosedIndex($data)
		{
			$openChar = $data[0];

			switch ($openChar) {
				case '('     :
					$closeChar   = ')';
					break;
				case '{'     :
					$closeChar = '}';
					break;

			}

			$length     = strlen($data) - 1;
			$counter    = 0;
			$offset     = 0;

			if (substr_count($data, $openChar) !== substr_count($data, $closeChar)) {
				throw Core::error('Invalid syntax');
			}

			do {
				$char = $data[$offset];
				$offset++;

				if ($char === $openChar || $char === $closeChar) {
					$counter++;

					if ($counter % 2) {
						continue;
					} else {
						if ($char !== $openChar) {
							return $offset;
						}
					}
				}
			} while ($offset <= $length);
		}

		/**
		 * Description goes here ...
		 * 
		 * @access   public
		 * @param    $source (required)
		 */
		public function tokenize($source)
		{
			$length   = strlen($source);
			$tokens   = array();
			$brackets = array('(', '{');
			$strChars = array("'", '"', "\140");

			do {
				$pos = strpos($source, ' ');

				if ($pos !== false) {
					if (in_array($source[0], $brackets)) {
						$pos = $this->loopToClosedIndex($source);
					}

					$value    = substr($source, 0, $pos);
					$source  = substr($source, $pos + 1, strlen($source) - 1);
					$tokens[] = $this->parseToken($value);
				} else {
					if (trim($source) !== '') {
						$tokens[] = $this->parseToken($source);
					}
					break;
				}
			} while ($pos < ($length - 1));

			parent::__construct($tokens);
		}

		/**
		 * Description goes here ...
		 * 
		 * @access   public
		 * @param    $value (required)
		 */
		public function getConstant($value)
		{
			$name = __NAMESPACE__ .'\\Lexer::T_' . strtoupper($value);

			if (defined($name)) {
				$code = constant($name);

				if ($code > 1000) {
					return $code;
				}
			}

			return self::T_IDENTIFIER;
		}
	}
?>