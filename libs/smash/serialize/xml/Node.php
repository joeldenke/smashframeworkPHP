<?php
/**
 * 
 * Generated by
 * Smash Framework Commentator
 * with PHP Version 5.3.4
 * 
 *  DESCRIPTION
 * Smash Framework is a Open Source PHP web framework to make it easier, efficient and more fun to create web applications.
 * 
 *  LICENSE
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 * 
 * @author      Joel Denke <mail@happyness.se>
 * @category    Smash - Smash Makes A Sweet Harmony
 * @copyright   (C) 2011 Joel Denke
 * @license     http://www.opensource.org/licenses/gpl-3.0.html - GNU General Public License version 3
 * @version     alpha 0.1
 */
	namespace Smash\Serialize\Xml;
	
	use	Smash\Core,
		Smash\Storage\Config;

	/**
	 * Description goes here ...
	 * 
	 * @namespace   Smash\Serialize\Xml
	 * @uses        Smash\Core,  Smash\Storage\Config
	 * @package     Node
	 * @author      Joel Denke <mail@happyness.se>
	 * @license     http://www.opensource.org/licenses/gpl-3.0.html - GNU General Public License version 3
	 */
	class Node
	{
		private $options = array(
			'addAttributes' => true
		);

		/**
		 * Description goes here ...
		 * 
		 * @access   public
		 * @param    $config (optional)
		 */
		public function __construct($config = null)
		{
			if ($config instanceof Config) {
				$this->setOptions($config->asArray());
			} else if (is_array($config)) {
				$this->setOptions($config);
			}
		}

		/**
		 * Description goes here ...
		 * 
		 * @access   public
		 * @param    $options (Array, required)
		 */
		public function setOptions(array $options)
		{
			foreach ($options as $index => $value) {
				$this->setOption($index, $value);
			}
		}

		/**
		 * Description goes here ...
		 * 
		 * @access   public
		 */
		public function getOptions()
		{
			return $this->options;
		}

		/**
		 * Description goes here ...
		 * 
		 * @access   public
		 * @param    $index (required)
		 */
		public function getOption($index)
		{
			if (array_key_exists($index, $this->options)) {
				return $this->options[$index];
			} else {
				throw Core::error('Option "%option" is not available', array('option' => $index));
			}
		}

		/**
		 * Description goes here ...
		 * 
		 * @access   public
		 * @param    $index (required)
		 * @param    $value (required)
		 */
		public function setOption($index, $value)
		{
			if (array_key_exists($index, $this->options)) {
				$this->options[$index] = $value;
			}
		}

		/**
		 * Description goes here ...
		 * 
		 * @access   protected
		 * @param    $element (DOMNode Object, required)
		 * @param    $type (optional)
		 */
		protected function getName(\DOMNode $element, $type = null)
		{
			switch ($type) {
				case 'namespace' :
					if (!empty($element->prefix)) {
						return $element->prefix;
					} else {
						continue;
					}
					break;
				case 'tag' :
					return $element->nodeName;
					break;
				default :
					if (!empty($element->prefix)) {
						return $element->prefix .':'. $element->localName;
					} else {
						return $element->nodeName;
					}
					break;
			}
		}

		// Attribut kan ENDAST skickas med om det finns flera element inuti ett element. Om inte MÅSTE de försvinna för det går inte att lösa snyggt.
		// Om det ska fungera måste man ordna så att #text hänger med hela tiden eller något annat. Men då fungerar det inte som det ska.
		/**
		 * Description goes here ...
		 * 
		 * @access   public
		 * @param    $node (DOMNode Object, required)
		 */
		public function processNode(\DOMNode $node)
		{
			$nodeData = array();

			if ($node instanceof \DOMElement) {
				if ($node->hasChildNodes()) {
					$children = $node->childNodes;

					foreach ($children as $child) {
						$name   = $this->getName($child);
						$value  = $child->nodeValue;
						$parent = $child->parentNode;

						if ($child->hasChildNodes()) {
							$nodes  = $this->getChildren($child);
							// $count    = count($text);
							$number = count($this->getChildren($parent, $name));

							if ($number > 1) {
								$nodeData[$name][] = $this->mergeData($child);
							} else if (count($nodes) == 1) {
								$nodeData[$name] = $this->processSimple($nodes[0]);
							} else {
								$nodeData[$name] = $this->mergeData($child);
							}
						} else {
							if ($child instanceof \DOMCharacterData) {
								$data = $this->processSimple($child);

								if ($data !== false) {
									return $data;
								}
							}
						}
					}
				}
			}

			return $nodeData;
		}

		/**
		 * Description goes here ...
		 * 
		 * @access   protected
		 * @param    $child (DOMElement Object, required)
		 */
		protected function mergeData(\DOMElement $child)
		{
			$node = $this->processNode($child);
			$attr = $this->processAttributes($child);

			if (is_string($node) || is_int($node) || is_bool($node)) {
				if (!empty($attr)) {
					array_push($attr, $node);
					return $attr;
				} else {
					return $node;
				}
			} else {
				return array_merge($attr, $node);
			}
		}

		/**
		 * Description goes here ...
		 * 
		 * @access   protected
		 * @param    $element (DOMCharacterData Object, required)
		 */
		protected function processSimple(\DOMCharacterData $element)
		{
			$value = $element->nodeValue;

			switch ($element->nodeType) {
				case XML_TEXT_NODE :
					if (!$element->isWhitespaceInElementContent()) {
						return trim($value);
					} else {
						return false;
					}
					break;
				case XML_ELEMENT_NODE :
					$value = trim($value);

					if ($value == '') {
						return null;
					}
					break;
				default :
					return $value;
					break;
			}
		}

		/**
		 * Description goes here ...
		 * 
		 * @access   protected
		 * @param    $element (required)
		 */
		protected function countAttributes($element)
		{
			$count = 0;

			if (array_key_exists('@attributes', $element)) {
				$attributes = $element['@attributes'];

				foreach ($attributes as $attribute) {
					$count++;
				}
			}

			return $count;
		}

		/**
		 * Description goes here ...
		 * 
		 * @access   protected
		 * @param    $element (DOMNode Object, required)
		 */
		protected function processAttributes(\DOMNode $element)
		{
			$attributes = array();

			if ($element->hasAttributes() && $this->getOption('addAttributes')) {
				foreach ($element->attributes as $attr) {
					$attributes['@attributes'][$attr->name] = $attr->value;
				}
			}

			return $attributes;
		}

		/**
		 * Description goes here ...
		 * 
		 * @access   public
		 * @param    $element (DOMElement Object, required)
		 * @param    $name (optional)
		 * @param    $type (optional)
		 */
		public function getChildren(\DOMElement $element, $name = null, $type = null)
		{
			$children = array();

			if ($element->hasChildNodes()) {
				if (empty($name)) {
					$nodes = $element->childNodes;
				} else if (strpos($name, ':') === false) {
					$nodes = $element->getElementsByTagName($name);
				} else {
					list($ns, $tag) = explode(':', $name, 2);

					$nodes = $element->getElementsByTagNameNS($ns, $name);

					/* foreach ($element->childNodes as $child) {
						if ($child->localName == $tag && $child->prefix == $ns) {
							$children[] = $child;
						}
					}*/
				}

				foreach ($nodes as $node) {
					switch ($type) {
						case 'element' :
						case 'text'    :							
							if ($node instanceof \DOMElement || $node instanceof \DOMText) {
								$children[] = $node;
							}
							break;
						default :
							$children[] = $node;
							break;
					}
				}
			}

			return $children;
		}
	}
?>