<?php
/**
 * 
 * Generated by
 * Smash Framework Commentator
 * with PHP Version 5.3.4
 * 
 *  DESCRIPTION
 * Smash Framework is a Open Source PHP web framework to make it easier, efficient and more fun to create web applications.
 * 
 *  LICENSE
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 * 
 * @author      Joel Denke <mail@happyness.se>
 * @category    Smash - Smash Makes A Sweet Harmony
 * @copyright   (C) 2011 Joel Denke
 * @license     http://www.opensource.org/licenses/gpl-3.0.html - GNU General Public License version 3
 * @version     alpha 0.1
 */
	namespace Smash\Serialize;
	
	use	Smash\Storage\Config,
		Smash\Core,
		Smash\Error,
		Smash\Library,
		Smash\Object;

	/**
	 * Description goes here ...
	 * 
	 * @namespace   Smash\Serialize
	 * @uses        Smash\Storage\Config,  Smash\Core,  Smash\Error,  Smash\Library,  Smash\Object
	 * @package     Xml
	 * @author      Joel Denke <mail@happyness.se>
	 * @license     http://www.opensource.org/licenses/gpl-3.0.html - GNU General Public License version 3
	 */
	class Xml
	{
		private $module    = null;
		private $options   = array(
			'version'       => '1.0',
			'encoding'      => 'utf-8',
			'indent'        => "\t",
			'doIndent'      => true,
			'rootNode'      => 'root',
			'rootAttr'      => array(),
			'skipRoot'      => false,
			'declaration'   => true,
			'addAttributes' => true,
			'output'        => 'array',
			'outputClass'   => 'stdClass'
		);

		/**
		 * Description goes here ...
		 * 
		 * @access   public
		 * @param    $config (optional)
		 */
		public function __construct($config = null)
		{
			if ($config instanceof Config) {
				$this->setOptions($config->asArray());
			} else if (is_array($config)) {
				$this->setOptions($config);
			}
		}

		/**
		 * Description goes here ...
		 * 
		 * @access   public
		 */
		public function __destruct()
		{
			$this->close();
		}

		/**
		 * Description goes here ...
		 * 
		 * @access   public
		 * @param    $in (required)
		 */
		public function escape($in)
		{
			$out = array();

			if (is_array($in) && !empty($in)) {
				foreach ($in as $key => $value) {
					if (is_string($key)) {
						$out[$this->escape($key)] = $this->escape($value);
					} else if (is_int($key)) {
						$out[$key] = $this->escape($value);
					}
				}
			} elseif(is_string($in)) {
				if (mb_detect_encoding($in, 'UTF-8, ISO-8859-1') !== 'UTF-8') {
					return utf8_encode($in);
				} else {
					return $in;
				}
			} else {
				return $in;
			}

			return $out;
		}

		/**
		 * Description goes here ...
		 * 
		 * @access   public
		 * @param    $module (required)
		 */
		public function load($module)
		{
			switch (strtolower($module)) {
				case 'reader' :
					$this->module = new \XMLReader;
					break;
				case 'writer' :
					$this->module = new \XMLWriter;
					$this->module->openMemory();
					break;
				default       :
					throw Core::error('Module %module is not valid', array('module' => $module));
					break;
			}

			return $this->module;
		}

		/**
		 * Description goes here ...
		 * 
		 * @access   public
		 */
		public function close()
		{
			if ($this->module instanceof \XMLReader) {
				$this->module->close();
			} else if ($this->module instanceof \XMLWriter) {
				$this->module->flush();
			}
		}

		/**
		 * Description goes here ...
		 * 
		 * @access   public
		 * @param    $options (Array, required)
		 */
		public function setOptions(array $options)
		{
			foreach ($options as $index => $value) {
				$this->setOption($index, $value);
			}
		}

		/**
		 * Description goes here ...
		 * 
		 * @access   public
		 */
		public function getOptions()
		{
			return $this->options;
		}

		/**
		 * Description goes here ...
		 * 
		 * @access   public
		 * @param    $index (required)
		 */
		public function getOption($index)
		{
			if (array_key_exists($index, $this->options)) {
				return $this->options[$index];
			} else {
				throw Core::error('config.option-not-exists', array('option' => $index));
			}
		}

		/**
		 * Description goes here ...
		 * 
		 * @access   public
		 * @param    $index (required)
		 * @param    $value (required)
		 */
		public function setOption($index, $value)
		{
			if (array_key_exists($index, $this->options)) {
				$this->options[$index] = $value;
			}
		}

		/**
		 * Description goes here ...
		 * 
		 * @access   public
		 */
		public function getData()
		{
			return $this->data;
		}

		/**
		 * Description goes here ...
		 * 
		 * @access   public
		 * @param    $data (required)
		 */
		public function serialize($data)
		{
			$xml      = $this->load('writer');
			$rootNode = $this->getOption('rootNode');
			$rootAttr = $this->escape($this->getOption('rootAttr'));
			$indent   = $this->getOption('indent');

			if ($indent) {
				$xml->setIndent(true);
				$xml->setIndentString($indent);
			}

			if ($this->getOption('declaration')) {
				$xml->startDocument($this->getOption('version'), $this->getOption('encoding'));
			}

			if (is_string($rootNode)) {
				$xml->startElement($rootNode);

				foreach ($rootAttr as $key => $attribute) {
					$xml->writeAttribute($key, $attribute);
				}

				$this->import($xml, $data, $rootNode);
				$xml->endElement();
			} else {
				$this->import($xml, $data);
			}

			$xml->endDocument();

			return $xml->flush();
		}

		/**
		 * Description goes here ...
		 * 
		 * @access   public
		 * @param    $tag (required)
		 * @param    $content (optional)
		 * @param    $attributes (Array)
		 * @param    $xml (optional)
		 */
		public function simpleTag($tag, $content = '', array $attributes = array(), $xml = null)
		{
			if (!is_string($tag) || strlen($tag) < 1) {
				throw Core::error('Invalid XML tag provided', array('tag' => $tag));
			}

			if (!$xml instanceof \XMLWriter) {
				$xml = $this->load('writer');
			}

			$attributes = $this->escape($attributes);

			if ($this->getOption('indent')) {
				$xml->setIndent(true);
				$xml->setIndentString($this->getOption('indent'));
			}

			$xml->startElement($tag);

			foreach ($attributes as $key => $attribute) {
				$xml->writeAttribute($key, $attribute);
			}

			if (!empty($content)) {
				$xml->writeRaw($content);
				$xml->endElement();
			} else {
				$xml->endElement();
			}

			return $xml->flush();
		}

		/**
		 * Description goes here ...
		 * 
		 * @access   public
		 * @param    $data (required)
		 * @param    $input (optional)
		 */
		public function unserialize($data, $input = null)
		{
			$xml = $this->load('reader');

			if (is_file($data)) {
				$xml->open($data);
			} else if (is_string($data)) {
				$xml->XML($data);
			} else {
				throw Core::error(
					'Input has to be a valid XML data or file, you specified: "%data"',
					array('data' => $data)
				);
			}

			switch ($this->getOption('output')) {
				case 'array'  :
				case 'assoc'  :
					if (!is_array($input)) {
						$input = array();
					}

					$data = $this->export($xml, $input);
					break;
				case 'object' :
				case 'class'  :
					if (!is_object($input)) {
						$input = $this->getOption('outputClass');
					}
					$data = $this->export($xml, $input);
					break;
				default       :
					throw Core::error('Type %type is not valid to unserialize', array('type' => $this->getOption('output')));
			}

			$this->close();
			return $data;
		}

		/**
		 * Description goes here ...
		 * 
		 * @access   public
		 * @param    $xml (XMLWriter Object, required)
		 * @param    $data (Array, required)
		 */
		public function writeAttributes(\XMLWriter $xml, array $data)
		{
			if (array_key_exists('@attributes', $data)) {
				$attributes = $data['@attributes'];

				foreach ($attributes as $attr => $attrValue) {
					$xml->writeAttribute($attr, $attrValue);
				}

				unset($data['@attributes']);
			}

			return $data;
		}

		/**
		 * Description goes here ...
		 * 
		 * @access   private
		 * @param    $xml (XMLWriter Object, required)
		 * @param    $data (required)
		 */
		private function import(\XMLWriter $xml, $data)
		{
			if (is_object($data)) {
				$obj  = Object::singleton();
				$data = $obj->asArray($data);
			}

			// $data = $this->escape($data);

			if (is_array($data)) {
				$data = $this->writeAttributes($xml, $data);

				foreach ($data as $tag => $content) {
					$keys = $this->getKeysFromTag($data, $tag);

					if (is_array($content) && isset($content['@data'])) {
						$xml->startElement($tag);
						$content = $this->writeAttributes($xml, $content);
						$xml->writeRaw($content['@data']);
						$xml->endElement();
					} else if (count($keys) > 0) {
						foreach ($keys as $key) {
							if (is_array($content)) {
								if (is_array($content[$key])) {
									$xml->startElement($tag);
									$this->import($xml, $content[$key]);
									$xml->endElement();
								} else {
									$xml->writeElement($tag, $content[$key]);
								}
							} else {
								$xml->writeElement($tag, $content);
							}
						}
					} else if (preg_match('/^[a-zедц][a-zедц0-9]+$/i', $tag)) {
						if (is_array($content)) {
							$xml->startElement($tag);
							$this->import($xml, $content);
							$xml->endElement();
						} else {
							$xml->startElement($tag);
							$xml->text($content);
							$xml->endElement();
						}
					} else {
						throw Core::error('Invalid tag %tag specified', array('tag' => $tag), Error::CODE_CORE);
					}
				}
			} else {
				throw Core::error('We need an array for translation of data into XML', array('data' => $data));
			}
		}

		/**
		 * Description goes here ...
		 * 
		 * @access   protected
		 * @param    $tag (required)
		 */
		protected function checkTag($tag)
		{
			if (!preg_match('/^[a-z\_\-.:]+$/i', $tag)) {
				return false;
			} else {
				return true;
			}
		}

		/**
		 * Description goes here ...
		 * 
		 * @access   protected
		 * @param    $data (Array, required)
		 * @param    $tag (required)
		 */
		protected function getKeysFromTag(array $data, $tag)
		{
			$found = array();

			if (array_key_exists($tag, $data)) {
				if (is_array($data[$tag])) {
					$keys = array_keys($data[$tag]);

					foreach ($keys as $key) {
						if (is_int($key)) {
							$found[] = $key;
						}
					}
				}
			}

			return $found;
		}

		/**
		 * Description goes here ...
		 * 
		 * @access   private
		 * @param    $xml (XMLReader Object, required)
		 * @param    $data (required)
		 */
		private function export(\XMLReader $xml, $data)
		{
			if (is_string($data) || is_object($data)) {
				$obj = Object::singleton();
				return $obj->toObject($this->parse($xml), $data);
			} else if (is_array($data)) {
				return array_merge($data, $this->parse($xml));
			} else {
				throw Core::error('Invalid data specified', array('data' => $data));
			}
		}

		/**
		 * Description goes here ...
		 * 
		 * @access   public
		 * @param    $xml (XMLReader Object, required)
		 */
		public function parse(\XMLReader $xml)
		{
			$data = null;
			$node = Library::factory('serialize.xml.node', $this->getOptions());

			try {
				$xml->read();
				$tree = $xml->expand();

				if ($this->getOption('skipRoot')) {
					$data = $node->processNode($tree);
				} else {
					$data[$tree->nodeName] = $node->processNode($tree);
				}
			} catch (\Exception $e) {
				throw Core::error('DOM error: "%error" with code "%code"', array('error' => $e->getMessage(), 'code' => $e->getCode()), $e->getCode());
			}

			if (is_array($data)) {
				return $data;
			} else {
				return array();
			}

			$this->close();
		}
	}
?>