<?php	
	/**
	 * 
	 * Generated by
	 * Smash Framework Commentator
	 * with PHP Version 5.3.4
	 * 
	 *  DESCRIPTION
	 * Smash Framework is a Open Source PHP web framework to make it easier, efficient and more fun to create web applications.
	 * 
	 *  LICENSE
	 * This program is free software: you can redistribute it and/or modify
	 * it under the terms of the GNU General Public License as published by
	 * the Free Software Foundation, either version 3 of the License, or
	 * (at your option) any later version.
	 * 
	 * This program is distributed in the hope that it will be useful,
	 * but WITHOUT ANY WARRANTY; without even the implied warranty of
	 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	 * GNU General Public License for more details.
	 * 
	 * You should have received a copy of the GNU General Public License
	 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
	 * 
	 * @author      Joel Denke <mail@happyness.se>
	 * @category    Smash - Smash Makes A Sweet Harmony
	 * @copyright   (C) 2011 Joel Denke
	 * @license     http://www.opensource.org/licenses/gpl-3.0.html - GNU General Public License version 3
	 * @version     alpha 0.1
	 */
	namespace Smash\Serialize;
	
	use	Smash\Library,
		Smash\Core,
		Smash\Serialize\Php as PHP,
		Smash\Storage\Filestream as Stream;
	
	/**
	 * Description goes here ...
	 * 
	 * @namespace   Smash\Serialize
	 * @uses        Smash\Library,  Smash\Core,  Smash\Serialize\Php as PHP,  Smash\Storage\Filestream as Stream
	 * @package     Commentator
	 * @author      Joel Denke <mail@happyness.se>
	 * @license     http://www.opensource.org/licenses/gpl-3.0.html - GNU General Public License version 3
	 */
	class Commentator
	{
		const STYLE_APPEND  = 10;
		const STYLE_PREPEND = 20;
		
		private $input     = array();
		private $output    = array();
		private $options   = array(
			'author'        => 'Author\'s name',
			'category'      => 'CategoryName',
			'email'         => 'author@mail.com',
			'license'       => 'gplv3',
			'copyright'     => null,
			'version'       => null,
			'year'          => null,
			'description'   => null,
			'wordwrap'      => 75,
			'recursive'     => true,
			'indent'        => "\t",
			'filePrefix'    => false,
			'fileExtension' => 'php',
			'fileSkip'      => true		
		);
		
		/**
		 * Description goes here ...
		 * 
		 * @access   public
		 * @param    $input (optional)
		 * @param    $output (optional)
		 * @param    $options (Array)
		 */
		public function __construct($input = null, $output = null, array $options = array())
		{
			if (is_readable($input)) {
				if (is_file($input)) {
					if (!empty($output)) {
						if (!is_readable($output)) {
							throw Core::error('Output %output need to be a readable resource', array('output' => $output));
						}
					}
					
					$this->addFile($input, $output);
				} else if (is_dir($input)) {
					if (!empty($output)) {
						if (!is_dir($output) || !is_readable($output)) {
							throw Core::error('Output %output need to be same ideal resource as input %input', array('input' => $input, 'output' => $output));
						}
					}
					
					$this->addDirectory($input, $output);
				}			
			} else {
				throw Core::error('Input need to be a readable resource of type file or directory');
			}

			foreach ($options as $key => $option) {
				if (array_key_exists($key, $this->options)) {
					$this->options[$key] = $option;
				}
			}
		}
		
		/**
		 * Description goes here ...
		 * 
		 * @access   public
		 * @param    $input (required)
		 * @param    $output (required)
		 */
		public function addDirectory($input, $output)
		{
			$dir = Library::factory('storage.directory', $output);
			$it  = new \RecursiveIteratorIterator(new \RecursiveDirectoryIterator($input), \RecursiveIteratorIterator::SELF_FIRST);
			
			foreach ($it as $name => $entry) {
				if ($it->isDot()) {
					continue;
				} else if ($entry->isFile()) {
					$sub  = $it->getSubPath();
					$path = rtrim($output, Core::DS) . Core::DS . (empty($sub) ? null : $sub . Core::DS);
					
					if ($this->options['fileSkip'] && file_exists($path . $entry->getFilename())) {
						continue;
					} else {
						echo $path . $entry->getFilename().Core::CRLF;
						
						if (!file_exists($path)) {
							$dir->createDir($path);
						}
						
						$this->addFile($name, $path . $entry->getFilename());
					}
				}
			}
		}
		
		/**
		 * Description goes here ...
		 * 
		 * @access   public
		 * @param    $input (required)
		 * @param    $output (required)
		 */
		public function addFile($input, $output)
		{
			$ext = pathinfo($input, PATHINFO_EXTENSION);
			
			if (strtolower($ext) == $this->options['fileExtension']) {
				$this->input[] = $input;
				
				if (!empty($output)) {
					$this->output[$input] = $output;
				}
			}
		}
		
		/**
		 * Description goes here ...
		 * 
		 * @access   public
		 * @param    $options (Array)
		 */
		public function generate(array $options = array())
		{
			$paths = array();
			
			foreach ($options as $key => $option) {
				if (array_key_exists($key, $this->options)) {
					$this->options[$key] = $option;
				}
			}
			
			foreach ($this->input as $file) {
				$php    = Library::factory('serialize.php', $file);
				$blocks = $this->parseFile($php, $file);
				$path   = $file;
				
				if (array_key_exists($file, $this->output)) {
					$path = $this->output[$file];
				}
				if (is_string($this->options['filePrefix'])) {
					$path = dirname($path) . Core::DS . $this->options['filePrefix'] . basename($path);
				}
				
				if ($this->writeTofile($blocks, $php, $path)) {
					$paths[] = $path;
				}
			}
			
			return $paths;
		}

		/**
		 * Description goes here ...
		 * 
		 * @access   public
		 * @param    $blocks (Array, required)
		 * @param    $php (required)
		 * @param    $file (required)
		 */
		public function writeToFile(array $blocks, $php, $file)
		{			
			$stream = new Stream($file, Stream::MODE_WRITE);
			$output = array();
			$lines  = $php->getLines();
			
			foreach ($lines as $line => $tokens) {
				$indent  = str_repeat($this->options['indent'], substr_count($tokens[0]->data, "\t"));
				$tmpData = '';
				
				foreach ($tokens as $token) {
					$tmpData .= $token->data;
				}
				
				if (array_key_exists($line, $blocks)) {
					$block = $blocks[$line];
					
					if ($block['style'] === self::STYLE_APPEND) {
						$output[] = $tmpData;
					}
					
					foreach ($block['block'] as $row) {
						$output[] = $indent . $row;
					}
					
					if ($block['style'] === self::STYLE_PREPEND) {
						$output[] = $tmpData;
					}
				} else {
					$output[] = $tmpData;
				}
			}
			
			return $stream->write(implode($output));
		}
		
		/**
		 * Description goes here ...
		 * 
		 * @access   public
		 * @param    $php (required)
		 * @param    $file (required)
		 */
		public function parseFile($php, $file)
		{			
			try {
				$classes   = array();
				$open      = $php->skipUntil(T_OPEN_TAG);
				$firstLine = $open->line;
				
				if ($php->skipUntil(T_NAMESPACE) !== false) {
					$php->match(T_WHITESPACE);
					$namespace = implode($php->loopFetchUntil(PHP::T_SEMICOLON)) .'\\';
				} else {
					$namespace = null;
				}
				
				if ($php->skipUntil(T_USE) !== false) {
					$php->match(T_WHITESPACE);
					
					$uses    = $php->loopFetchUntil(PHP::T_SEMICOLON);
					$tmp     = '';
					$values  = implode($uses);
					$classes = explode(',', $values);
					
					foreach ($classes as $key => $value) {
						$classes[$key] = preg_replace('/\s\s+/', ' ', $classes[$key]);
					}
				}
				
				$php->rewind();
				$php->skipUntil(array(T_CLASS, T_INTERFACE));
				
				$matches = $php->match(array(T_WHITESPACE, T_STRING));
				$class   = $namespace . array_shift($matches);
				
				if (!empty($class)) {
					if (!class_exists($class, false) && !interface_exists($class, false)) {
						if (!in_array($file, get_included_files())) {
							include $file;
						}
					}
					
					return $this->generateDocBlocks($php, $class, $classes, $firstLine);
				} else {
					return array();
				}
			} catch (\Exception $e) {
				return array();
			}
		}
		
		/**
		 * Description goes here ...
		 * 
		 * @access   public
		 * @param    $values (Array, required)
		 * @param    $style (optional)
		 * @param    $max (optional)
		 */
		public function getLength(array $values, $style = null, $max = true)
		{
			switch ($style) {
				case 'values' :
					$elements = array_values($values);
					break;
				case 'key'  :
				case 'keys' :
				default     :
					$elements = array_keys($values);
					break;
			}
			
			usort($elements, function($a, $b){
			return strlen($b) - strlen($a);
			});
			
			return $max ? strlen(array_shift($elements)) : strlen(array_pop($elements));
		}
		
		/**
		 * Description goes here ...
		 * 
		 * @access   public
		 * @param    $firstLine (required)
		 */
		public function getPageBlock($firstLine)
		{
			$block = array();
			
			if (($pos = strpos(phpversion(), '-')) !== false) {
				$phpVersion = substr(phpversion(), 0, $pos);
			} else {
				$phpVersion = phpversion();
			}
			
			$license = Library::factory('serialize.commentator.license', $this->options);
			$parts   = $license->getLicense();
			$block[] = '';
			$block[] = 'Generated by';
			$block[] = 'Smash Framework Commentator';
			$block[] = 'with PHP Version '. $phpVersion;
			
			if (!empty($this->options['description'])) {
				$block[] = '';
				$block[] = ' DESCRIPTION';
				
				if (is_string($this->options['description'])) {
					$block[] = $this->options['description'];
				} else if (is_array($this->options['description'])) {
					foreach ($this->options['description'] as $row) {
						$block[] = $row;
					}
				}
			}
			
			$block[] = '';
			$block[] = ' LICENSE';
			
			foreach ($parts as $part) {
				$block[] = $part;
			}
			
			$block[] = '';
			ksort($this->options);
			
			foreach ($this->options as $key => $value) {
				switch ($key) {
					case 'copyright' :
						if (empty($this->options['year'])) {
							$this->options['year'] = date('Y');
						}
						$block[$key] = '(C) '. $this->options['year'] .' '. $this->options['author'];
						break;
					case 'category'  :
					case 'package'   :
					case 'version'   :
					case 'link'      :
						$block[$key] = $value;
						break;
					case 'author'    :
						$block[$key] = $value .' <'. $this->options['email'] .'>';
						break;
					case 'license'   :
						$block[$key] = $license->getLicense('link') .' - '. $license->getLicense('name');
						break;
				}
			}
			
			return array($firstLine => $block);
		}
		
		/**
		 * Description goes here ...
		 * 
		 * @access   public
		 * @param    $reflection (ReflectionClass Object, required)
		 * @param    $classes (Array, required)
		 */
		public function getClassBlock(\ReflectionClass $reflection, array $classes)
		{
			$block      = array();
			$license    = Library::factory('serialize.commentator.license', $this->options);
			$interfaces = $reflection->getInterfaceNames();
			$parents    = array();
			
			if ($parent = $reflection->getParentClass()) {
				$parents[] = $parent->getName();
			}
			
			$stacks = array('uses' => $classes, 'extends' => $parents, 'interfaces' => $interfaces);
			
			$block[] = 'Description goes here ...';
			$block[] = '';
			
			if ($reflection->inNamespace()) {
				$block['namespace'] = $reflection->getNamespaceName();
			}
			
			foreach ($stacks as $key => $stack) {
				if (!empty($stack)) {
					$block[$key] = implode(', ', $stack);
				}
			}
			
			$block['package'] = $reflection->getShortName();
			$block['author']  = $this->options['author'] .' <'. $this->options['email'] .'>';
			$block['license'] = $license->getLicense('link') .' - '. $license->getLicense('name');
			
			return array($reflection->getStartLine() => $block);
		}
		
		/**
		 * Description goes here ...
		 * 
		 * @access   public
		 * @param    $reflection (ReflectionClass Object, required)
		 */
		public function getMethodBlocks(\ReflectionClass $reflection)
		{
			$blocks  = array();
			
			foreach ($reflection->getMethods() as $method) {
				if ($method->getDocComment() === false && $method->isUserDefined()) {
					$block  = array();
					$params = \Smash\Object::getParamTypes($method);
					
					$block[] = 'Description goes here ...';
					$block[] = '';
					$block['access'] = implode(', ', \Reflection::getModifierNames($method->getModifiers()));
					
					foreach ($params as $param) {
						$block['param'][] = $param;
					}
					
					$blocks[$method->getStartLine()] = $block;
				}
			}
			
			return $blocks;
		}
		
		/**
		 * Description goes here ...
		 * 
		 * @access   public
		 * @param    $php (required)
		 * @param    $reflection (ReflectionClass Object, required)
		 */
		public function getPropertyBlocks($php, \ReflectionClass $reflection)
		{
			$blocks  = array();
			
			// @TODO Get properties by tokens here
			
			/*foreach ($reflection->getProperties() as $property) {
				if ($property->getDocComment() === false) {
					$block   = array();
					$block[] = 'Description goes here ...';
					$block[] = '';
					
					$block['var']     = $property->getName();
					$block['access']  = implode(', ', \Reflection::getModifierNames($property->getModifiers()));
					
					$blocks[$property->getStartLine()] = $block; // Start line isnt implemented for properties yet
				}
			}*/
			
			return $blocks;
		}
		
		/**
		 * Description goes here ...
		 * 
		 * @access   public
		 * @param    $php (required)
		 * @param    $reflection (ReflectionClass Object, required)
		 */
		public function getConstantBlocks($php, \ReflectionClass $reflection)
		{
			$blocks  = array();
			
			// @TODO Get constants by tokens here
			
			/*
			foreach ($reflection->getConstants() as $constant) {
				if ($constant->getDocComment() === false) {
					$block   = array();
					$block[] = 'Description goes here ...';
					$block[] = '';
					
					$block['var']     = $property->getName();
					$block['access']  = implode(', ', \Reflection::getModifierNames($property->getModifiers()));
					
					$blocks[$property->getStartLine()] = $block; // Start line isnt implemented for properties yet
				}
			}*/
			
			return $blocks;
		}
		
		/**
		 * Description goes here ...
		 * 
		 * @access   public
		 * @param    $rows (Array, required)
		 */
		public function convertToDocBlock(array $rows)
		{
			$block   = array();
			$prefix  = ' * ';
			$length  = $this->getLength($rows);
			
			foreach ($rows as $key => $row) {
				$space = str_repeat(' ', $length - strlen($key) + 3);
				
				if (is_array($row)) {
					foreach ($row as $rkey => $rvalue) {
						$block[] = $prefix. '@'. $key . $space . $rvalue . Core::CRLF;
					}
				} else if (is_string($key)) {
					$block[] = $prefix. '@'. $key . $space . $row . Core::CRLF;
				} else {
					$block[] = $prefix. $row . Core::CRLF;
				}
			}
			
			array_unshift($block, '/**'. Core::CRLF);
			array_push($block, ' */'. Core::CRLF);
			
			return $block;
		}
		
		/**
		 * Description goes here ...
		 * 
		 * @access   public
		 * @param    $php (required)
		 * @param    $class (required)
		 * @param    $classes (Array, required)
		 * @param    $firstLine (required)
		 */
		public function generateDocBlocks($php, $class, array $classes, $firstLine)
		{	
			$reflection         = new \ReflectionClass($class);
			$blocks             = array();
			$data               = array();
			$data['page']       = $this->getPageBlock($firstLine);
			$data['class']      = $this->getClassBlock($reflection, $classes);
			$data['methods']    = $this->getMethodBlocks($reflection);
			$data['properties'] = $this->getPropertyBlocks($php, $reflection);
			$data['constants']  = $this->getConstantBlocks($php, $reflection);
			
			foreach ($data as $key => $datablock) {
				$style = $key === 'page' ? self::STYLE_APPEND : self::STYLE_PREPEND;
				
				foreach ($datablock as $line => $block) {
					$blocks[$line] = array('block' => $this->convertToDocBlock($block), 'style' => $style);
				}
			}
			
			return $blocks;
		}
	}
	
?>