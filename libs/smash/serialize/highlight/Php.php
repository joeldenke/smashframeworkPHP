<?php
/**
 * 
 * Generated by
 * Smash Framework Commentator
 * with PHP Version 5.3.4
 * 
 *  DESCRIPTION
 * Smash Framework is a Open Source PHP web framework to make it easier, efficient and more fun to create web applications.
 * 
 *  LICENSE
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 * 
 * @author      Joel Denke <mail@happyness.se>
 * @category    Smash - Smash Makes A Sweet Harmony
 * @copyright   (C) 2011 Joel Denke
 * @license     http://www.opensource.org/licenses/gpl-3.0.html - GNU General Public License version 3
 * @version     alpha 0.1
 */
	namespace Smash\Serialize\Highlight;
	
	use	Smash\Core,
		Smash\Library,
		Smash\Serialize\Php as Lexer;	

	/**
	 * Description goes here ...
	 * 
	 * @namespace    Smash\Serialize\Highlight
	 * @uses         Smash\Core,  Smash\Library,  Smash\Serialize\Php as Lexer
	 * @extends      ArrayIterator
	 * @interfaces   Countable, Serializable, SeekableIterator, ArrayAccess, Traversable, Iterator, Smash\Serialize\Highlight\Surface
	 * @package      PHP
	 * @author       Joel Denke <mail@happyness.se>
	 * @license      http://www.opensource.org/licenses/gpl-3.0.html - GNU General Public License version 3
	 */
	class PHP extends \ArrayIterator implements Surface
	{
		private $styles = array(
			'string'    => 'highlight.string',
			'comment'   => 'highlight.comment',
			'keyword'   => 'highlight.keyword',
			'bg'        => 'highlight.bg',
			'default'   => 'highlight.default',
			'html'      => 'highlight.html',
			'variable'  => 'highlight.variable'
		);
		private $options    = array(
			'manual'        => '<a href="http://www.php.net/%s">%s</a>',
			'span'          => '<span class="%s">%s</span>',
			'inline'        => false,
			'funcref'       => true,
		);

		/**
		 * Description goes here ...
		 * 
		 * @access   public
		 * @param    $source (required)
		 * @param    $options (optional)
		 */
		public function __construct($source, $options = null)
		{
			if (is_array($options)) {
				foreach ($options as $option => $value) {
					if (isset($this->options[$option])) {
						$this->options[$option] = $value;
					}
				}
				
				if ($this->options['inline'] === false) {
					$this->setStyles(array(
						'string'    => ini_get('highlight.string'),
						'comment'   => ini_get('highlight.comment'),
						'keyword'   => ini_get('highlight.keyword'),
						'bg'        => ini_get('highlight.bg'),
						'default'   => ini_get('highlight.default'),
						'html'      => ini_get('highlight.html'),
						'variable'  => ini_get('highlight.default'),
					));
					$this->setOption('span', '<span style="color: %s;">%s</span>');
				}
			}
			
			$php = Library::factory('serialize.php', $source);
			parent::__construct($php->getLines());
		}

		/**
		 * Description goes here ...
		 * 
		 * @access   public
		 * @param    $option (required)
		 */
		public function getOption($option)
		{
			if (array_key_exists($option, $this->options)) {
				return $this->options[$option];
			} else {
				throw Core::error('Option "'. $option .'" is not available');
			}
		}
		
		/**
		 * Description goes here ...
		 * 
		 * @access   public
		 * @param    $array (required)
		 * @param    $elements (required)
		 * @param    $index (required)
		 */
		public function insert_array_elements($array, $elements, $index)
		{
			if (!is_array($elements)) $elements = (array)$elements;
			array_splice($array, $index, count($array), array_merge($elements, array_slice($array, $index)));
			
			return $array;
		}

		/**
		 * Description goes here ...
		 * 
		 * @access   public
		 * @param    $option (required)
		 * @param    $value (required)
		 * @param    $strict (optional)
		 */
		public function setOption($option, $value, $strict = true)
		{
			if (array_key_exists($option, $this->options)) {
				$this->options[$option] = $value;
			} else {
				if ($strict === true) {
					throw Core::error('Option "'. $option .'" is not available');
				} else {
					return false;
				}
			}
		}

		/**
		 * Description goes here ...
		 * 
		 * @access   public
		 * @param    $line (required)
		 */
		public function processLine($line)
		{
			$parts = array();

			if ($this->offsetExists($line)) {
				$tokens = $this->offsetGet($line);

				foreach ($tokens as $key => $token) {
					switch ($token->type) {
						case T_WHITESPACE :
							$parts[] = $token->data;
							break;
						default :
							if ($token->type == T_STRING && function_exists($token->data)) {
								if ($this->getOption('funcref')) {
									$parts[] = $this->parseBlock('manual', $token->data, $token->data);
								} else {
									$parts[] = $this->parseBlock('keyword', $token->data);
								}
							} else {
								$parts[] = $this->parseBlock($token->type, $token->data);
							}
							break;
					}
				}
			}

			return $parts;
		}

		/**
		 * Description goes here ...
		 * 
		 * @access   private
		 * @param    $block (required)
		 * @param    $data (required)
		 */
		private function parseBlock($block, $data)
		{
			if ($block === 'manual') {
					return sprintf($this->getOption($block), $data, $data);
			} else {
					return sprintf($this->getOption('span'), $this->highlightToken($block), $data);
			}
		}

		/**
		 * Description goes here ...
		 * 
		 * @access   public
		 * @param    $key (required)
		 * @param    $style (required)
		 * @param    $strict (optional)
		 */
		public function setStyle($key, $style, $strict = true)
		{
			if (array_key_exists($key, $this->styles)) {
   				if (is_string($style)) {
					$this->styles[$key] = $style;
				} else {
					throw Core::error(
						'Invalid format for color "%key" with resource type "%type", has to be string resource',
						array('key' => $key, 'type' => get_resource_type($style), 'color' => $style)
					);
				}
			} else {
				if ($strict === true) {
					throw Core::error(
						'Color with key code "%key" is not supported',
						array('key' => $key, 'color' => $style)
					);
				} else {
					return false;
				}
			}
		}

		/**
		 * Description goes here ...
		 * 
		 * @access   public
		 * @param    $styles (Array, required)
		 */
		public function setStyles(array $styles)
		{
			foreach ($styles as $key => $style) {
				$this->setStyle($key, $style, false);
			}

			return $this;
		}

		/**
		 * Description goes here ...
		 * 
		 * @access   public
		 * @param    $token (required)
		 */
		public function highlightToken($token)
		{
			switch($token) {
				case T_CONSTANT_ENCAPSED_STRING :
					return $this->styles['string'];
					break;
				case T_INLINE_HTML :
					return $this->styles['html'];
					break;
				case T_COMMENT :
				case T_DOC_COMMENT :
					return $this->styles['comment'];
					break;
				case Lexer::T_SEMICOLON :
				case Lexer::T_OPEN_CURLY_BRACKET :
				case Lexer::T_CLOSE_CURLY_BRACKET :
				case Lexer::T_OPEN_SQUARE_BRACKET :
				case Lexer::T_CLOSE_SQUARE_BRACKET :
				case T_ABSTRACT :
				case T_ARRAY :
				case T_ARRAY_CAST :
				case T_AS :
				case T_BOOLEAN_AND :
				case T_BOOLEAN_OR :
				case T_BOOL_CAST :
				case T_BREAK :
				case T_CASE :
				case T_CATCH :
				case T_CLASS :
				case T_CLONE :
				case T_CONCAT_EQUAL :
				case T_CONTINUE :
				case T_DEFAULT :
				case T_DOUBLE_ARROW :
				case T_DOUBLE_CAST :
				case T_ECHO :
				case T_ELSE :
				case T_ELSEIF :
				case T_EMPTY :
				case T_ENDDECLARE :
				case T_ENDFOR :
				case T_ENDFOREACH :
				case T_ENDIF :
				case T_ENDSWITCH :
				case T_ENDWHILE :
				case T_END_HEREDOC :
				case T_EXIT :
				case T_EXTENDS :
				case T_FINAL :
				case T_FOREACH :
				case T_FUNCTION :
				case T_GLOBAL :
				case T_IF :
				case T_IMPLEMENTS :
				case T_INC :
				case T_INCLUDE :
				case T_INCLUDE_ONCE :
				case T_INSTANCEOF :
				case T_INT_CAST :
				case T_INTERFACE :
				case T_ISSET :
				case T_IS_EQUAL :
				case T_IS_IDENTICAL :
				case T_IS_NOT_IDENTICAL :
				case T_IS_SMALLER_OR_EQUAL :
				case T_NEW :
				case T_OBJECT_CAST :
				case T_OBJECT_OPERATOR :
				case T_PAAMAYIM_NEKUDOTAYIM :
				case T_PRIVATE :
				case T_PROTECTED :
				case T_PUBLIC :
				case T_REQUIRE :
				case T_REQUIRE_ONCE :
				case T_RETURN :
				case T_SL :
				case T_SL_EQUAL :
				case T_SR :
				case T_SR_EQUAL :
				case T_START_HEREDOC :
				case T_STATIC :
				case T_STRING_CAST :
				case T_SWITCH :
				case T_THROW :
				case T_TRY :
				case T_UNSET_CAST :
				case T_VAR :
				case T_WHILE :
					return $this->styles['keyword'];
					break;
				case T_VARIABLE:
					return $this->styles['variable'];
					break;
				case T_CLOSE_TAG :
				case T_OPEN_TAG :
				case T_OPEN_TAG_WITH_ECHO :
				default :
					if (array_key_exists($token, $this->styles)) {
						return $this->styles[$token];
					} else {
						return $this->styles['default'];
					}
			}
		}
	}
?>