<?php
/**
 * 
 * Generated by
 * Smash Framework Commentator
 * with PHP Version 5.3.4
 * 
 *  DESCRIPTION
 * Smash Framework is a Open Source PHP web framework to make it easier, efficient and more fun to create web applications.
 * 
 *  LICENSE
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 * 
 * @author      Joel Denke <mail@happyness.se>
 * @category    Smash - Smash Makes A Sweet Harmony
 * @copyright   (C) 2011 Joel Denke
 * @license     http://www.opensource.org/licenses/gpl-3.0.html - GNU General Public License version 3
 * @version     alpha 0.1
 */
	namespace Smash;

	/**
	 * Description goes here ...
	 * 
	 * @namespace   Smash
	 * @package     Library
	 * @author      Joel Denke <mail@happyness.se>
	 * @license     http://www.opensource.org/licenses/gpl-3.0.html - GNU General Public License version 3
	 */
	class Library
	{
		static private $loadedClasses = array();
		static private $namespaces    = array();
		static private $instances     = array();
		static private $extension     = '.php';

		/**
		 * Description goes here ...
		 * 
		 * @access   public, static
		 */
		static public function factory()
		{
			$params = func_get_args();
			$class  = array_shift($params);

			if (is_string($class) || $class instanceof \ReflectionClass) {
				return self::factoryByParams($class, $params);
			} else {
				throw Core::error('class.param-wrong-type', array('number' => 1, 'type' => 'string'), Error::CODE_CORE);
			}
		}

		/**
		 * Description goes here ...
		 * 
		 * @access   public, static
		 * @param    $class (required)
		 * @param    $params (Array, required)
		 */
		static public function factoryByParams($class, array $params)
		{
			if ($class instanceof \ReflectionClass) {
				$reflect = $class;
			} else {
				$class   = self::load($class);
				$reflect = new \ReflectionClass($class);
			}

			if ($reflect->isInstantiable()) {
				if ($reflect->hasMethod('__construct')) {
					$method = $reflect->getMethod('__construct');

					if ($method->getNumberOfParameters() > 0 && count($params) > 0) {
						return $reflect->newInstanceArgs($params);
					} else {
						return $reflect->newInstance();
					}
				} else {
					return $reflect->newInstance();
				}
			} else {
				throw Core::error('class.not-instantiable', array('class' => $class), Error::CODE_CORE);
			}
		}

		/**
		 * Description goes here ...
		 * 
		 * @access   public, static
		 * @param    $class (required)
		 * @param    $spec (optional)
		 */
		static public function dependecy($class, $spec = null)
		{
			if (is_object($class)) {
				if (is_string($spec)) {
					if ($class instanceof $spec) {
						return $spec;
					} else {
						return false;
					}
				}
			} else {
				if (self::exists($class)) {
					return self::fetch($class);
				} else {
					$params   = func_get_args();
					$class    = array_shift($params);
					$instance = self::factoryByParams($class, $params);

					if (!self::exists($class)) {
						self::store($class, $instance);
					}

					return $instance;
				}
			}

			return false;
		}
		
		/**
		 * Description goes here ...
		 * 
		 * @access   public, static
		 * @param    $input (required)
		 * @param    $dir (optional)
		 */
		static public function addNameSpaces($input, $dir = null)
		{
			if (is_array($input)) {
				self::$namespaces = array_merge(self::$namespaces, $input);
			} else if (is_string($input)) {
				if (is_dir($input)) {
					foreach (new \DirectoryIterator($input) as $entry) {
						if ($entry->isDir() && !$entry->isDot()) {
							$namespace = ucfirst(strtolower($entry->getFilename()));
							
							if (!isset(self::$namespaces[$namespace])) {
								self::$namespaces[$namespace] = $entry->getPathname();
							}
						}
					}
				} else {
					if (!isset(self::$namespaces[$input])) {
						$input = ucfirst(strtolower($input));
						self::$namespaces[$input] = $dir;
					}
				}
			}
		}
		
		/**
		 * Description goes here ...
		 * 
		 * @access   public, static
		 */
		static public function getNamespaces()
		{
			return self::$namespaces;
		}

		/**
		 * Description goes here ...
		 * 
		 * @access   public, static
		 * @param    $parts (required)
		 * @param    $default (optional)
		 */
		static public function appendNamespace($parts, $default = 'Smash')
		{
			$name = ucfirst(strtolower($parts[0]));

			if (!array_key_exists($name, self::$namespaces)) {
				array_unshift($parts, $default);
			}
			
			return $parts;
		}
		
		/**
		 * Description goes here ...
		 * 
		 * @access   public, static
		 */
		static public function register()
		{
			spl_autoload_register(array(__CLASS__, 'autoload'));
		}

		/**
		 * Description goes here ...
		 * 
		 * @access   public, static
		 * @param    $class (required)
		 */
		static public function autoload($class)
		{			
			try {
				return self::load($class);
			} catch (Error $e) {
				echo $e;
			}
		}

		/**
		 * Description goes here ...
		 * 
		 * @access   public, static
		 * @param    $class (required)
		 */
		static public function load($class)
		{
			if (class_exists($class, false) || interface_exists($class, false)) {
				return $class;
			}
			
			$class = ltrim($class, '\\');
			$class = str_replace(array('_', '.', '::', '\\'), '@', strtolower($class));
			$parts = explode('@', $class);
			$class = implode('\\', array_map('ucfirst', self::appendNamespace($parts)));
			
			if ($lastNsPos = strripos($class, '\\')) {
				$namespace = substr($class, 0, $lastNsPos);
				
				foreach (self::$namespaces as $ns => $dir) {
					if (strpos($namespace, $ns) === 0) {
						if ($ns === 'Smash') {
							$namespace = strtolower($namespace);
						}
						
						$className = substr($class, $lastNsPos + 1);
						$file  = rtrim($dir, Core::DS) . Core::DS . str_replace('\\', Core::DS, $namespace) . Core::DS . $className . self::$extension;
						
						if (!file_exists($file)) {
							throw Core::error('File %file does not exists', array('file' => $file));
						} else {
							if (!in_array($file, get_included_files())) {
								include $file;
							}

							return $class;
						}
					}
				}
			}
		}

		/**
		 * Description goes here ...
		 * 
		 * @access   public, static
		 * @param    $section (required)
		 * @param    $value (required)
		 * @param    $strict (optional)
		 */
		static public function store($section, $value, $strict = true)
		{
			if (isset(self::$instances[$section])) {
				if ($strict === true) {
					throw Core::error('class.library-section-exist', array('section' => $section), Error::CODE_CORE);
				} else {
					return false;
				}
			} else {
				self::$instances[$section] = $value;
			}
		}

		/**
		 * Description goes here ...
		 * 
		 * @access   public, static
		 * @param    $section (required)
		 * @param    $default (optional)
		 */
		static public function fetch($section, $default = false)
		{
			if (isset(self::$instances[$section])) {
				return self::$instances[$section];
			} else {
				return $default;
			}
		}

		/**
		 * Description goes here ...
		 * 
		 * @access   public, static
		 * @param    $section (required)
		 */
		static public function remove($section)
		{
			if (isset(self::$instances[$section])) {
				unset(self::$instances[$section]);
			} else {
				throw Core::error('class.library-section-not-exist', array('section' => $section), Error::CODE_CORE);
			}
		}

		/**
		 * Description goes here ...
		 * 
		 * @access   public, static
		 * @param    $library (required)
		 */
		static public function clearLibrary($library)
		{
			self::$instances = array();
		}

		/**
		 * Description goes here ...
		 * 
		 * @access   public, static
		 * @param    $section (required)
		 */
		static public function exists($section)
		{
			return isset(self::$instances[$section]);
		}
	}
?>